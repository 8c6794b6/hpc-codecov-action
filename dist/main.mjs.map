{
  "version": 3,
  "sources": ["../node_modules/@actions/core/src/utils.ts", "../node_modules/@actions/core/src/command.ts", "../node_modules/uuid/dist/esm-node/rng.js", "../node_modules/uuid/dist/esm-node/regex.js", "../node_modules/uuid/dist/esm-node/validate.js", "../node_modules/uuid/dist/esm-node/stringify.js", "../node_modules/uuid/dist/esm-node/v1.js", "../node_modules/uuid/dist/esm-node/parse.js", "../node_modules/uuid/dist/esm-node/v35.js", "../node_modules/uuid/dist/esm-node/md5.js", "../node_modules/uuid/dist/esm-node/v3.js", "../node_modules/uuid/dist/esm-node/v4.js", "../node_modules/uuid/dist/esm-node/sha1.js", "../node_modules/uuid/dist/esm-node/v5.js", "../node_modules/uuid/dist/esm-node/nil.js", "../node_modules/uuid/dist/esm-node/version.js", "../node_modules/uuid/dist/esm-node/index.js", "../node_modules/@actions/core/src/file-command.ts", "../node_modules/@actions/http-client/src/proxy.ts", "../node_modules/tunnel/lib/tunnel.js", "../node_modules/tunnel/index.js", "../node_modules/@actions/http-client/src/index.ts", "../node_modules/@actions/http-client/src/auth.ts", "../node_modules/@actions/core/src/oidc-utils.ts", "../node_modules/@actions/core/src/summary.ts", "../node_modules/@actions/core/src/path-utils.ts", "../node_modules/@actions/core/src/core.ts", "../node_modules/@actions/io/src/io-util.ts", "../node_modules/@actions/io/src/io.ts", "../node_modules/@actions/exec/src/toolrunner.ts", "../node_modules/@actions/exec/src/exec.ts", "../.spago/prelude/v6.0.1/src/Control/Semigroupoid.purs", "../.spago/prelude/v6.0.1/src/Control/Category.purs", "../.spago/prelude/v6.0.1/src/Data/Boolean.purs", "../.spago/prelude/v6.0.1/src/Data/Function.purs", "../.spago/prelude/v6.0.1/src/Data/Functor.purs", "../.spago/prelude/v6.0.1/src/Control/Apply.purs", "../.spago/prelude/v6.0.1/src/Control/Applicative.purs", "../.spago/prelude/v6.0.1/src/Control/Bind.purs", "../output/Data.Semigroup/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Semigroup.purs", "../.spago/control/v6.0.0/src/Control/Alt.purs", "../output/Data.Bounded/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Semiring.purs", "../output/Data.Show/foreign.js", "../.spago/prelude/v6.0.1/src/Data/Show.purs", "../.spago/maybe/v6.0.0/src/Data/Maybe.purs", "../.spago/either/v6.1.0/src/Data/Either.purs", "../output/Effect/foreign.js", "../.spago/prelude/v6.0.1/src/Control/Monad.purs", "../.spago/prelude/v6.0.1/src/Data/Monoid.purs", "../.spago/effect/v4.0.0/src/Effect.purs", "../output/Effect.Exception/foreign.js", "../.spago/transformers/v6.0.0/src/Control/Monad/Error/Class.purs", "../.spago/identity/v6.0.0/src/Data/Identity.purs", "../.spago/transformers/v6.0.0/src/Control/Monad/Trans/Class.purs", "../.spago/effect/v4.0.0/src/Effect/Class.purs", "../.spago/transformers/v6.0.0/src/Control/Monad/Except/Trans.purs", "../output/Effect.Aff/foreign.js", "../output/Unsafe.Coerce/foreign.js", "../.spago/control/v6.0.0/src/Control/Plus.purs", "../.spago/safe-coerce/v2.0.0/src/Safe/Coerce.purs", "../.spago/newtype/v5.0.0/src/Data/Newtype.purs", "../.spago/parallel/v6.0.0/src/Control/Parallel/Class.purs", "../output/Data.Foldable/foreign.js", "../.spago/foldable-traversable/v6.0.0/src/Data/Foldable.purs", "../output/Data.Traversable/foreign.js", "../.spago/parallel/v6.0.0/src/Control/Parallel.purs", "../output/Partial.Unsafe/foreign.js", "../output/Partial/foreign.js", "../.spago/partial/v4.0.0/src/Partial.purs", "../.spago/partial/v4.0.0/src/Partial/Unsafe.purs", "../.spago/aff/v7.1.0/src/Effect/Aff.purs", "../output/GitHub.Actions.Core/foreign.js", "../output/Control.Promise/foreign.js", "../.spago/transformers/v6.0.0/src/Control/Monad/Except.purs", "../.spago/nonempty/v7.0.0/src/Data/NonEmpty.purs", "../.spago/lists/v7.0.0/src/Data/List/Types.purs", "../output/Foreign/foreign.js", "../.spago/lists/v7.0.0/src/Data/List/NonEmpty.purs", "../.spago/foreign/v7.0.0/src/Foreign.purs", "../.spago/aff-promise/v4.0.0/src/Control/Promise.purs", "../output/Effect.Uncurried/foreign.js", "../.spago/github-actions-toolkit/v0.5.0/src/GitHub/Actions/Core.purs", "../output/GitHub.Actions.Exec/foreign.js", "../output/Data.Nullable/foreign.js", "../.spago/nullable/v6.0.0/src/Data/Nullable.purs", "../.spago/github-actions-toolkit/v0.5.0/src/GitHub/Actions/Exec.purs", "../output/Node.FS.Async/foreign.js", "../output/Node.FS.Constants/foreign.js", "../output/Data.String.CodePoints/foreign.js", "../output/Data.Array/foreign.js", "../output/Data.Array.ST/foreign.js", "../.spago/node-fs/v8.2.0/src/Node/FS/Perms.purs", "../.spago/node-fs/v8.2.0/src/Node/FS/Async.purs", "../.spago/node-fs-aff/v9.2.0/src/Node/FS/Aff.purs", "../output/Node.Path/foreign.js", "../.spago/node-process/v10.0.0/src/Node/Platform.purs", "../output/Node.Process/foreign.js", "../output/Foreign.Object/foreign.js", "../.spago/node-process/v10.0.0/src/Node/Process.purs", "../src/Main.purs", "../js/entry.js"],
  "sourcesContent": [null, null, "import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;", "import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;", "import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "import crypto from 'crypto';\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('md5').update(bytes).digest();\n}\n\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;", "import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;", "import crypto from 'crypto';\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('sha1').update(bytes).digest();\n}\n\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;", "export default '00000000-0000-0000-0000-000000000000';", "import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;", "export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';", null, null, "'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n", "module.exports = require('./lib/tunnel');\n", null, null, null, null, null, null, null, null, null, null, "module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n", "module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n", "module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n", "module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n", "module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n", "module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n", "module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n", "module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f\u2019 -> map f\u2019 x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n", "export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n", "module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n", "export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n", "module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n", "export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n", "module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n", "module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n", "module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n", "export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n", "module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n", "module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n", "-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n", "export function showErrorImpl(err) {\n  return err.stack || err.toString();\n}\n\nexport function error(msg) {\n  return new Error(msg);\n}\n\nexport function message(e) {\n  return e.message;\n}\n\nexport function name(e) {\n  return e.name || \"Error\";\n}\n\nexport function stackImpl(just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n}\n\nexport function throwException(e) {\n  return function () {\n    throw e;\n  };\n}\n\nexport function catchException(c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n}\n", "-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n\n-- | Lift a `Maybe` value to a MonadThrow monad.\nliftMaybe :: forall m e a. MonadThrow e m => e -> Maybe a -> m a\nliftMaybe error = maybe (throwError error) pure\n\n-- | Lift an `Either` value to a MonadThrow monad.\nliftEither :: forall m e a. MonadThrow e m => Either e a -> m a\nliftEither = either throwError pure\n", "module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdentity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n", "-- | This module defines the `MonadTrans` type class of _monad transformers_.\n\nmodule Control.Monad.Trans.Class where\n\nimport Prelude (class Monad)\n\n-- | The `MonadTrans` type class represents _monad transformers_.\n-- |\n-- | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which\n-- | takes a `Monad` as its first argument, and returns another `Monad`.\n-- |\n-- | This allows us to add additional effects to an existing monad. By iterating this\n-- | process, we create monad transformer _stacks_, which contain all of the effects\n-- | required for a particular computation.\n-- |\n-- | The laws state that `lift` is a `Monad` morphism.\n-- |\n-- | Laws:\n-- |\n-- | - `lift (pure a) = pure a`\n-- | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`\nclass MonadTrans t where\n  lift :: forall m a. Monad m => m a -> t m a\n", "module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n", "-- | This module defines the _exception monad transformer_ `ExceptT`.\n\nmodule Control.Monad.Except.Trans\n  ( ExceptT(..), runExceptT, withExceptT, mapExceptT, except\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.Error.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, throwError, catchError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, pass, listen, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Either (Either(..), either)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..))\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | A monad transformer which adds exceptions to other monads, in the same way\n-- | as `Except`. As before, `e` is the type of exceptions, and `a` is the type\n-- | of successful results. The new type parameter `m` is the inner monad that\n-- | computations run in.\nnewtype ExceptT e m a = ExceptT (m (Either e a))\n\n-- | The inverse of `ExceptT`. Run a computation in the `ExceptT` monad.\nrunExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\nrunExceptT (ExceptT x) = x\n\n-- | Transform any exceptions thrown by an `ExceptT` computation using the given function.\nwithExceptT :: forall e e' m a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a\nwithExceptT f (ExceptT t) = ExceptT $ map (mapLeft f) t\n  where\n  mapLeft _ (Right x) = Right x\n  mapLeft f' (Left x) = Left (f' x)\n\n-- | Transform the unwrapped computation using the given function.\nmapExceptT :: forall e e' m n a b. (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b\nmapExceptT f (ExceptT m) = ExceptT (f m)\n\n-- | Construct a computation in the `ExceptT` transformer from an `Either` value.\nexcept :: forall e m a. Applicative m => Either e a -> ExceptT e m a\nexcept = ExceptT <<< pure\n\nderive instance newtypeExceptT :: Newtype (ExceptT e m a) _\n\ninstance functorExceptT :: Functor m => Functor (ExceptT e m) where\n  map f = mapExceptT (map (map f))\n\ninstance applyExceptT :: Monad m => Apply (ExceptT e m) where\n  apply = ap\n\ninstance applicativeExceptT :: Monad m => Applicative (ExceptT e m) where\n  pure = ExceptT <<< pure <<< Right\n\ninstance bindExceptT :: Monad m => Bind (ExceptT e m) where\n  bind (ExceptT m) k =\n    ExceptT (m >>= either (pure <<< Left) (\\a -> case k a of ExceptT b -> b))\n\ninstance monadExceptT :: Monad m => Monad (ExceptT e m)\n\ninstance monadRecExceptT :: MonadRec m => MonadRec (ExceptT e m) where\n  tailRecM f = ExceptT <<< tailRecM \\a ->\n    case f a of\n      ExceptT m -> m >>= \\m' ->\n        pure case m' of\n          Left e -> Done (Left e)\n          Right (Loop a1) -> Loop a1\n          Right (Done b) -> Done (Right b)\n\ninstance altExceptT :: (Semigroup e, Monad m) => Alt (ExceptT e m) where\n  alt (ExceptT m) (ExceptT n) = ExceptT do\n    rm <- m\n    case rm of\n      Right x -> pure (Right x)\n      Left err -> do\n        rn <- n\n        case rn of\n          Right x -> pure (Right x)\n          Left err' -> pure (Left (err <> err'))\n\ninstance plusExceptT :: (Monoid e, Monad m) => Plus (ExceptT e m) where\n  empty = throwError (mempty :: e)\n\ninstance alternativeExceptT :: (Monoid e, Monad m) => Alternative (ExceptT e m)\n\ninstance monadPlusExceptT :: (Monoid e, Monad m) => MonadPlus (ExceptT e m)\n\ninstance monadTransExceptT :: MonadTrans (ExceptT e) where\n  lift m = ExceptT do\n    a <- m\n    pure $ Right a\n\ninstance monadEffectExceptT :: MonadEffect m => MonadEffect (ExceptT e m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContExceptT :: MonadCont m => MonadCont (ExceptT e m) where\n  callCC f = ExceptT $ callCC \\c ->\n    case f (\\a -> ExceptT $ c (Right a)) of ExceptT b -> b\n\ninstance monadThrowExceptT :: Monad m => MonadThrow e (ExceptT e m) where\n  throwError = ExceptT <<< pure <<< Left\n\ninstance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m) where\n  catchError (ExceptT m) k =\n    ExceptT (m >>= either (\\a -> case k a of ExceptT b -> b) (pure <<< Right))\n\ninstance monadAskExceptT :: MonadAsk r m => MonadAsk r (ExceptT e m) where\n  ask = lift ask\n\ninstance monadReaderExceptT :: MonadReader r m => MonadReader r (ExceptT e m) where\n  local f = mapExceptT (local f)\n\ninstance monadStateExceptT :: MonadState s m => MonadState s (ExceptT e m) where\n  state f = lift (state f)\n\ninstance monadTellExceptT :: MonadTell w m => MonadTell w (ExceptT e m) where\n  tell = lift <<< tell\n\ninstance monadWriterExceptT :: MonadWriter w m => MonadWriter w (ExceptT e m) where\n  listen = mapExceptT \\m -> do\n    Tuple a w <- listen m\n    pure $ (\\r -> Tuple r w) <$> a\n  pass = mapExceptT \\m -> pass do\n    a <- m\n    pure case a of\n      Left e -> Tuple (Left e) identity\n      Right (Tuple r f) -> Tuple (Right r) f\n\ninstance semigroupExceptT :: (Monad m, Semigroup a) => Semigroup (ExceptT e m a) where\n  append = lift2 (<>)\n\ninstance monoidExceptT :: (Monad m, Monoid a) => Monoid (ExceptT e m a) where\n  mempty = pure mempty\n\n", "/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n\n  /*\n\n  An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n\n  data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n\n  */\n  var PURE    = \"Pure\";\n  var THROW   = \"Throw\";\n  var CATCH   = \"Catch\";\n  var SYNC    = \"Sync\";\n  var ASYNC   = \"Async\";\n  var BIND    = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK    = \"Fork\";\n  var SEQ     = \"Sequential\";\n\n  /*\n\n  data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n\n  */\n  var MAP   = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT   = \"Alt\";\n\n  // Various constructors used in interpretation\n  var CONS      = \"Cons\";      // Cons-list, for stacks\n  var RESUME    = \"Resume\";    // Continue indiscriminately\n  var RELEASE   = \"Release\";   // Continue with bracket finalizers\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n  var FORKED    = \"Forked\";    // Reference to a forked fiber, with resumption stack\n  var FIBER     = \"Fiber\";     // Actual fiber reference\n  var THUNK     = \"Thunk\";     // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1  = _1;\n    this._2  = _2;\n    this._3  = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit    = 1024;\n    var size     = 0;\n    var ix       = 0;\n    var queue    = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n      while (size !== 0) {\n        size--;\n        thunk     = queue[ix];\n        queue[ix] = void 0;\n        ix        = (ix + 1) % limit;\n        thunk();\n      }\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers  = {};\n    var fiberId = 0;\n    var count   = 0;\n\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills     = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers  = {};\n          fiberId = 0;\n          count   = 0;\n\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  }\n\n  // Fiber state machine\n  var SUSPENDED   = 0; // Suspended, pending a join.\n  var CONTINUE    = 1; // Interpret the next instruction.\n  var STEP_BIND   = 2; // Apply the next bind.\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n  var PENDING     = 4; // An async effect is running.\n  var RETURN      = 5; // The current stack has returned.\n  var COMPLETED   = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0;\n\n    // The current branch of the state machine.\n    var status = SUSPENDED;\n\n    // The current point of interest for the state machine branch.\n    var step      = aff;  // Successful step\n    var fail      = null; // Failure step\n    var interrupt = null; // Asynchronous interrupt\n\n    // Stack of continuations for the current fiber.\n    var bhead = null;\n    var btail = null;\n\n    // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n    var attempts = null;\n\n    // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n    var bracketCount = 0;\n\n    // Each join gets a new id so they can be revoked.\n    var joinId  = 0;\n    var joins   = null;\n    var rethrow = true;\n\n    // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n    function run(localRunTick) {\n      var tmp, result, attempt;\n      while (true) {\n        tmp       = null;\n        result    = null;\n        attempt   = null;\n\n        switch (status) {\n        case STEP_BIND:\n          status = CONTINUE;\n          try {\n            step   = bhead(step);\n            if (btail === null) {\n              bhead = null;\n            } else {\n              bhead = btail._1;\n              btail = btail._2;\n            }\n          } catch (e) {\n            status = RETURN;\n            fail   = util.left(e);\n            step   = null;\n          }\n          break;\n\n        case STEP_RESULT:\n          if (util.isLeft(step)) {\n            status = RETURN;\n            fail   = step;\n            step   = null;\n          } else if (bhead === null) {\n            status = RETURN;\n          } else {\n            status = STEP_BIND;\n            step   = util.fromRight(step);\n          }\n          break;\n\n        case CONTINUE:\n          switch (step.tag) {\n          case BIND:\n            if (bhead) {\n              btail = new Aff(CONS, bhead, btail);\n            }\n            bhead  = step._2;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case PURE:\n            if (bhead === null) {\n              status = RETURN;\n              step   = util.right(step._1);\n            } else {\n              status = STEP_BIND;\n              step   = step._1;\n            }\n            break;\n\n          case SYNC:\n            status = STEP_RESULT;\n            step   = runSync(util.left, util.right, step._1);\n            break;\n\n          case ASYNC:\n            status = PENDING;\n            step   = runAsync(util.left, step._1, function (result) {\n              return function () {\n                if (runTick !== localRunTick) {\n                  return;\n                }\n                runTick++;\n                Scheduler.enqueue(function () {\n                  // It's possible to interrupt the fiber between enqueuing and\n                  // resuming, so we need to check that the runTick is still\n                  // valid.\n                  if (runTick !== localRunTick + 1) {\n                    return;\n                  }\n                  status = STEP_RESULT;\n                  step   = result;\n                  run(runTick);\n                });\n              };\n            });\n            return;\n\n          case THROW:\n            status = RETURN;\n            fail   = util.left(step._1);\n            step   = null;\n            break;\n\n          // Enqueue the Catch so that we can call the error handler later on\n          // in case of an exception.\n          case CATCH:\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead    = null;\n            btail    = null;\n            status   = CONTINUE;\n            step     = step._1;\n            break;\n\n          // Enqueue the Bracket so that we can call the appropriate handlers\n          // after resource acquisition.\n          case BRACKET:\n            bracketCount++;\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead  = null;\n            btail  = null;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case FORK:\n            status = STEP_RESULT;\n            tmp    = Fiber(util, supervisor, step._2);\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n            if (step._1) {\n              tmp.run();\n            }\n            step = util.right(tmp);\n            break;\n\n          case SEQ:\n            status = CONTINUE;\n            step   = sequential(util, supervisor, step._1);\n            break;\n          }\n          break;\n\n        case RETURN:\n          bhead = null;\n          btail = null;\n          // If the current stack has returned, and we have no other stacks to\n          // resume or finalizers to run, the fiber has halted and we can\n          // invoke all join callbacks. Otherwise we need to resume.\n          if (attempts === null) {\n            status = COMPLETED;\n            step   = interrupt || fail || step;\n          } else {\n            // The interrupt status for the enqueued item.\n            tmp      = attempts._3;\n            attempt  = attempts._1;\n            attempts = attempts._2;\n\n            switch (attempt.tag) {\n            // We cannot recover from an unmasked interrupt. Otherwise we should\n            // continue stepping, or run the exception handler if an exception\n            // was raised.\n            case CATCH:\n              // We should compare the interrupt status as well because we\n              // only want it to apply if there has been an interrupt since\n              // enqueuing the catch.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                status = RETURN;\n              } else if (fail) {\n                status = CONTINUE;\n                step   = attempt._2(util.fromLeft(fail));\n                fail   = null;\n              }\n              break;\n\n            // We cannot resume from an unmasked interrupt or exception.\n            case RESUME:\n              // As with Catch, we only want to ignore in the case of an\n              // interrupt since enqueing the item.\n              if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                status = RETURN;\n              } else {\n                bhead  = attempt._1;\n                btail  = attempt._2;\n                status = STEP_BIND;\n                step   = util.fromRight(step);\n              }\n              break;\n\n            // If we have a bracket, we should enqueue the handlers,\n            // and continue with the success branch only if the fiber has\n            // not been interrupted. If the bracket acquisition failed, we\n            // should not run either.\n            case BRACKET:\n              bracketCount--;\n              if (fail === null) {\n                result   = util.fromRight(step);\n                // We need to enqueue the Release with the same interrupt\n                // status as the Bracket that is initiating it.\n                attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);\n                // We should only coninue as long as the interrupt status has not changed or\n                // we are currently within a non-interruptable finalizer.\n                if (interrupt === tmp || bracketCount > 0) {\n                  status = CONTINUE;\n                  step   = attempt._3(result);\n                }\n              }\n              break;\n\n            // Enqueue the appropriate handler. We increase the bracket count\n            // because it should not be cancelled.\n            case RELEASE:\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              // It has only been killed if the interrupt status has changed\n              // since we enqueued the item, and the bracket count is 0. If the\n              // bracket count is non-zero then we are in a masked state so it's\n              // impossible to be killed.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n              } else if (fail) {\n                step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n              } else {\n                step = attempt._1.completed(util.fromRight(step))(attempt._2);\n              }\n              fail = null;\n              bracketCount++;\n              break;\n\n            case FINALIZER:\n              bracketCount++;\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              step     = attempt._1;\n              break;\n\n            case FINALIZED:\n              bracketCount--;\n              status = RETURN;\n              step   = attempt._1;\n              fail   = attempt._2;\n              break;\n            }\n          }\n          break;\n\n        case COMPLETED:\n          for (var k in joins) {\n            if (joins.hasOwnProperty(k)) {\n              rethrow = rethrow && joins[k].rethrow;\n              runEff(joins[k].handler(step));\n            }\n          }\n          joins = null;\n          // If we have an interrupt and a fail, then the thread threw while\n          // running finalizers. This should always rethrow in a fresh stack.\n          if (interrupt && fail) {\n            setTimeout(function () {\n              throw util.fromLeft(fail);\n            }, 0);\n          // If we have an unhandled exception, and no other fiber has joined\n          // then we need to throw the exception in a fresh stack.\n          } else if (util.isLeft(step) && rethrow) {\n            setTimeout(function () {\n              // Guard on reathrow because a completely synchronous fiber can\n              // still have an observer which was added after-the-fact.\n              if (rethrow) {\n                throw util.fromLeft(step);\n              }\n            }, 0);\n          }\n          return;\n        case SUSPENDED:\n          status = CONTINUE;\n          break;\n        case PENDING: return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid    = joinId++;\n        joins      = joins || {};\n        joins[jid] = join;\n\n        return function() {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function (/* unused */) {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n        case SUSPENDED:\n          interrupt = util.left(error);\n          status    = COMPLETED;\n          step      = interrupt;\n          run(runTick);\n          break;\n        case PENDING:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            if (status === PENDING) {\n              attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n            }\n            status   = RETURN;\n            step     = null;\n            fail     = null;\n            run(++runTick);\n          }\n          break;\n        default:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            status = RETURN;\n            step   = null;\n            fail   = null;\n          }\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId   = 0;\n    var fibers    = {};\n\n    // Table of currently running cancelers, as a product of `Alt` behavior.\n    var killId    = 0;\n    var kills     = {};\n\n    // Error used for early cancelation on Alt branches.\n    var early     = new Error(\"[ParAff] Early exit\");\n\n    // Error used to kill the entire tree.\n    var interrupt = null;\n\n    // The root pointer of the tree.\n    var root      = EMPTY;\n\n    // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n    function kill(error, par, cb) {\n      var step  = par;\n      var head  = null;\n      var tail  = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n        case FORKED:\n          if (step._3 === EMPTY) {\n            tmp = fibers[step._1];\n            kills[count++] = tmp.kill(error, function (result) {\n              return function () {\n                count--;\n                if (count === 0) {\n                  cb(result)();\n                }\n              };\n            });\n          }\n          // Terminal case.\n          if (head === null) {\n            break loop;\n          }\n          // Go down the right side of the tree.\n          step = head._2;\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n          break;\n        case MAP:\n          step = step._2;\n          break;\n        case APPLY:\n        case ALT:\n          if (head) {\n            tail = new Aff(CONS, head, tail);\n          }\n          head = step;\n          step = step._1;\n          break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    }\n\n    // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null;\n\n        // We should never continue if the entire tree has been interrupted.\n        if (interrupt !== null) {\n          return;\n        }\n\n        // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        }\n\n        // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n        case MAP:\n          if (fail === null) {\n            head._3 = util.right(head._1(util.fromRight(step)));\n            step    = head._3;\n          } else {\n            head._3 = fail;\n          }\n          break;\n        case APPLY:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // If we have a failure we should kill the other side because we\n          // can't possible yield a result anymore.\n          if (fail) {\n            head._3 = fail;\n            tmp     = true;\n            kid     = killId++;\n\n            kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(fail, null, null);\n                } else {\n                  join(fail, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          } else if (lhs === EMPTY || rhs === EMPTY) {\n            // We can only proceed if both sides have resolved.\n            return;\n          } else {\n            step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n            head._3 = step;\n          }\n          break;\n        case ALT:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // We can only proceed if both have resolved or we have a success\n          if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n            return;\n          }\n          // If both sides resolve with an error, we should continue with the\n          // first error\n          if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n            fail    = step === lhs ? rhs : lhs;\n            step    = null;\n            head._3 = fail;\n          } else {\n            head._3 = step;\n            tmp     = true;\n            kid     = killId++;\n            // Once a side has resolved, we need to cancel the side that is still\n            // pending before we can continue.\n            kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(step, null, null);\n                } else {\n                  join(step, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          }\n          break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    }\n\n    // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n    function run() {\n      var status = CONTINUE;\n      var step   = par;\n      var head   = null;\n      var tail   = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n        case CONTINUE:\n          switch (step.tag) {\n          case MAP:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(MAP, step._1, EMPTY, EMPTY);\n            step = step._2;\n            break;\n          case APPLY:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(ALT, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          default:\n            // When we hit a leaf value, we suspend the stack in the `FORKED`.\n            // When the fiber resolves, it can bubble back up the tree.\n            fid    = fiberId++;\n            status = RETURN;\n            tmp    = step;\n            step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n            tmp    = Fiber(util, supervisor, tmp);\n            tmp.onComplete({\n              rethrow: false,\n              handler: resolve(step)\n            })();\n            fibers[fid] = tmp;\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n          }\n          break;\n        case RETURN:\n          // Terminal case, we are back at the root.\n          if (head === null) {\n            break loop;\n          }\n          // If we are done with the right side, we need to continue down the\n          // left. Otherwise we should continue up the stack.\n          if (head._1 === EMPTY) {\n            head._1 = step;\n            status  = CONTINUE;\n            step    = head._2;\n            head._2 = EMPTY;\n          } else {\n            head._2 = step;\n            step    = head;\n            if (tail === null) {\n              head  = null;\n            } else {\n              head  = tail._1;\n              tail  = tail._2;\n            }\n          }\n        }\n      }\n\n      // Keep a reference to the tree root so it can be cancelled.\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    }\n\n    // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY       = EMPTY;\n  Aff.Pure        = AffCtr(PURE);\n  Aff.Throw       = AffCtr(THROW);\n  Aff.Catch       = AffCtr(CATCH);\n  Aff.Sync        = AffCtr(SYNC);\n  Aff.Async       = AffCtr(ASYNC);\n  Aff.Bind        = AffCtr(BIND);\n  Aff.Bracket     = AffCtr(BRACKET);\n  Aff.Fork        = AffCtr(FORK);\n  Aff.Seq         = AffCtr(SEQ);\n  Aff.ParMap      = AffCtr(MAP);\n  Aff.ParApply    = AffCtr(APPLY);\n  Aff.ParAlt      = AffCtr(ALT);\n  Aff.Fiber       = Fiber;\n  Aff.Supervisor  = Supervisor;\n  Aff.Scheduler   = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n\n  return Aff;\n}();\n\nexport const _pure = Aff.Pure;\nexport const _throwError = Aff.Throw;\n\nexport function _catchError(aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n}\n\nexport function _map(f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n}\n\nexport function _bind(aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n}\n\nexport function _fork(immediate) {\n  return function (aff) {\n    return Aff.Fork(immediate, aff);\n  };\n}\n\nexport const _liftEffect = Aff.Sync;\n\nexport function _parAffMap(f) {\n  return function (aff) {\n    return Aff.ParMap(f, aff);\n  };\n}\n\nexport function _parAffApply(aff1) {\n  return function (aff2) {\n    return Aff.ParApply(aff1, aff2);\n  };\n}\n\nexport function _parAffAlt(aff1) {\n  return function (aff2) {\n    return Aff.ParAlt(aff1, aff2);\n  };\n}\n\nexport const makeAff = Aff.Async;\n\nexport function generalBracket(acquire) {\n  return function (options) {\n    return function (k) {\n      return Aff.Bracket(acquire, options, k);\n    };\n  };\n}\n\nexport function _makeFiber(util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n}\n\nexport function _makeSupervisedFiber(util, aff) {\n  return function () {\n    var supervisor = Aff.Supervisor(util);\n    return {\n      fiber: Aff.Fiber(util, supervisor, aff),\n      supervisor: supervisor\n    };\n  };\n}\n\nexport function _killAll(error, supervisor, cb) {\n  return supervisor.killAll(error, cb);\n}\n\nexport const _delay = function () {\n  function setDelay(n, k) {\n    if (n === 0 && typeof setImmediate !== \"undefined\") {\n      return setImmediate(k);\n    } else {\n      return setTimeout(k, n);\n    }\n  }\n\n  function clearDelay(n, t) {\n    if (n === 0 && typeof clearImmediate !== \"undefined\") {\n      return clearImmediate(t);\n    } else {\n      return clearTimeout(t);\n    }\n  }\n\n  return function (right, ms) {\n    return Aff.Async(function (cb) {\n      return function () {\n        var timer = setDelay(ms, cb(right()));\n        return function () {\n          return Aff.Sync(function () {\n            return right(clearDelay(ms, timer));\n          });\n        };\n      };\n    });\n  };\n}();\n\nexport const _sequential = Aff.Seq;\n", "// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n", "module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n", "module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n", "module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n", "module Control.Parallel.Class where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Cont.Trans (ContT(..), runContT)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Monad.Maybe.Trans (MaybeT(..))\nimport Control.Monad.Reader.Trans (mapReaderT, ReaderT)\nimport Control.Monad.Writer.Trans (mapWriterT, WriterT)\nimport Control.Plus (class Plus)\nimport Data.Either (Either)\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Costar (Costar(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Profunctor.Star (Star(..))\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Ref as Ref\n\n-- | The `Parallel` class abstracts over monads which support\n-- | parallel composition via some related `Applicative`.\nclass (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n  parallel :: m ~> f\n  sequential :: f ~> m\n\ninstance monadParExceptT :: Parallel f m => Parallel (Compose f (Either e)) (ExceptT e m) where\n  parallel (ExceptT ma) = Compose (parallel ma)\n  sequential (Compose fa) = ExceptT (sequential fa)\n\ninstance monadParReaderT :: Parallel f m => Parallel (ReaderT e f) (ReaderT e m) where\n  parallel = mapReaderT parallel\n  sequential = mapReaderT sequential\n\ninstance monadParWriterT :: (Monoid w, Parallel f m) => Parallel (WriterT w f) (WriterT w m) where\n  parallel = mapWriterT parallel\n  sequential = mapWriterT sequential\n\ninstance monadParMaybeT :: Parallel f m => Parallel (Compose f Maybe) (MaybeT m) where\n  parallel (MaybeT ma) = Compose (parallel ma)\n  sequential (Compose fa) = MaybeT (sequential fa)\n\ninstance monadParStar :: Parallel f m => Parallel (Star f a) (Star m a) where\n  parallel (Star f) = (Star $ parallel <<< f)\n  sequential (Star f) = (Star $ sequential <<< f)\n\ninstance monadParCostar :: Parallel f m => Parallel (Costar f a) (Costar m a) where\n  parallel (Costar f) = (Costar $ sequential >>> f)\n  sequential (Costar f) = (Costar $ parallel >>> f)\n\n\n-- | The `ParCont` type constructor provides an `Applicative` instance\n-- | based on `ContT Unit m`, which waits for multiple continuations to be\n-- | resumed simultaneously.\n-- |\n-- | ParCont sections of code can be embedded in sequential code by using\n-- | the `parallel` and `sequential` functions:\n-- |\n-- | ```purescript\n-- | loadModel :: ContT Unit (Eff (ajax :: AJAX)) Model\n-- | loadModel = do\n-- |   token <- authenticate\n-- |   sequential $\n-- |     Model <$> parallel (get \"/products/popular/\" token)\n-- |           <*> parallel (get \"/categories/all\" token)\n-- | ```\nnewtype ParCont m a = ParCont (ContT Unit m a)\n\nderive instance newtypeParCont :: Newtype (ParCont m a) _\n\ninstance functorParCont :: MonadEffect m => Functor (ParCont m) where\n  map f = parallel <<< map f <<< sequential\n\ninstance applyParCont :: MonadEffect m => Apply (ParCont m) where\n  apply (ParCont ca) (ParCont cb) = ParCont $ ContT \\k -> do\n    ra <- liftEffect (Ref.new Nothing)\n    rb <- liftEffect (Ref.new Nothing)\n\n    runContT ca \\a -> do\n      mb <- liftEffect (Ref.read rb)\n      case mb of\n        Nothing -> liftEffect (Ref.write (Just a) ra)\n        Just b -> k (a b)\n\n    runContT cb \\b -> do\n      ma <- liftEffect (Ref.read ra)\n      case ma of\n        Nothing -> liftEffect (Ref.write (Just b) rb)\n        Just a -> k (a b)\n\ninstance applicativeParCont :: MonadEffect m => Applicative (ParCont m) where\n  pure = parallel <<< pure\n\ninstance altParCont :: MonadEffect m => Alt (ParCont m) where\n  alt (ParCont c1) (ParCont c2) = ParCont $ ContT \\k -> do\n    done <- liftEffect (Ref.new false)\n\n    runContT c1 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\n    runContT c2 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\ninstance plusParCont :: MonadEffect m => Plus (ParCont m) where\n  empty = ParCont $ ContT \\_ -> pure unit\n\ninstance alternativeParCont :: MonadEffect m => Alternative (ParCont m)\n\ninstance monadParParCont :: MonadEffect m => Parallel (ParCont m) (ContT Unit m) where\n  parallel = ParCont\n  sequential (ParCont ma) = ma\n", "export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n", "module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  , lookup\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap _ Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap _ (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldableConst :: Foldable (Const a) where\n  foldr _ z _ = z\n  foldl _ z _ = z\n  foldMap _ _ = mempty\n\ninstance foldableProduct :: (Foldable f, Foldable g) => Foldable (Product f g) where\n  foldr f z (Product (Tuple fa ga)) = foldr f (foldr f z ga) fa\n  foldl f z (Product (Tuple fa ga)) = foldl f (foldl f z fa) ga\n  foldMap f (Product (Tuple fa ga)) = foldMap f fa <> foldMap f ga\n\ninstance foldableCoproduct :: (Foldable f, Foldable g) => Foldable (Coproduct f g) where\n  foldr f z = coproduct (foldr f z) (foldr f z)\n  foldl f z = coproduct (foldl f z) (foldl f z)\n  foldMap f = coproduct (foldMap f) (foldMap f)\n\ninstance foldableCompose :: (Foldable f, Foldable g) => Foldable (Compose f g) where\n  foldr f i (Compose fga) = foldr (flip (foldr f)) i fga\n  foldl f i (Compose fga) = foldl (foldl f) i fga\n  foldMap f (Compose fga) = foldMap (foldMap f) fga\n\ninstance foldableApp :: Foldable f => Foldable (App f) where\n  foldr f i (App x) = foldr f i x\n  foldl f i (App x) = foldl f i x\n  foldMap f (App x) = foldMap f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (b -> a -> m b) -> b -> f a -> m b\nfoldM f b0 = foldl (\\b a -> b >>= flip f a) (pure b0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n", "// jshint maxparams: 3\n\nexport const traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n", "module Control.Parallel\n  ( parApply\n  , parTraverse\n  , parTraverse_\n  , parSequence\n  , parSequence_\n  , parOneOf\n  , parOneOfMap\n  , module Control.Parallel.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Parallel.Class (class Parallel, parallel, sequential, ParCont(..))\n\nimport Data.Foldable (class Foldable, traverse_, oneOfMap)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | Apply a function to an argument under a type constructor in parallel.\nparApply\n  :: forall f m a b\n   . Parallel f m\n   => m (a -> b)\n   -> m a\n   -> m b\nparApply mf ma = sequential(apply (parallel mf) (parallel ma))\n\n-- | Traverse a collection in parallel.\nparTraverse\n  :: forall f m t a b\n   . Parallel f m\n  => Traversable t\n  => (a -> m b)\n  -> t a\n  -> m (t b)\nparTraverse f = sequential <<< traverse (parallel <<< f)\n\n-- | Traverse a collection in parallel, discarding any results.\nparTraverse_\n  :: forall f m t a b\n   . Parallel f m\n  => Foldable t\n  => (a -> m b)\n  -> t a\n  -> m Unit\nparTraverse_ f = sequential <<< traverse_ (parallel <<< f)\n\nparSequence\n  :: forall a t m f\n   . Parallel f m\n  => Traversable t\n  => t (m a)\n  -> m (t a)\nparSequence = parTraverse identity\n\nparSequence_\n  :: forall a t m f\n   . Parallel f m\n  => Foldable t\n  => t (m a)\n  -> m Unit\nparSequence_ = parTraverse_ identity\n\n-- | Race a collection in parallel.\nparOneOf\n  :: forall a t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => t (m a)\n  -> m a\nparOneOf = sequential <<< oneOfMap parallel\n\n-- | Race a collection in parallel while mapping to some effect.\nparOneOfMap\n  :: forall a b t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => (a -> m b)\n  -> t a\n  -> m b\nparOneOfMap f = sequential <<< oneOfMap (parallel <<< f)\n", "// module Partial.Unsafe\n\nexport const _unsafePartial = function (f) {\n  return f();\n};\n", "// module Partial\n\nexport const _crashWith = function (msg) {\n  throw new Error(msg);\n};\n", "-- | Some partial helper functions. See the README for more documentation.\nmodule Partial\n  ( crash\n  , crashWith\n  ) where\n\n-- | A partial function which crashes on any input with a default message.\ncrash :: forall a. Partial => a\ncrash = crashWith \"Partial.crash: partial function\"\n\n-- | A partial function which crashes on any input with the specified message.\ncrashWith :: forall a. Partial => String -> a\ncrashWith = _crashWith\n\nforeign import _crashWith :: forall a. String -> a\n", "-- | Utilities for working with partial functions.\n-- | See the README for more documentation.\nmodule Partial.Unsafe\n  ( unsafePartial\n  , unsafeCrashWith\n  ) where\n\nimport Partial (crashWith)\n\n-- Note: this function's type signature is more like\n-- `(Unit -> a) -> a`. However, we would need to use\n-- `unsafeCoerce` to make this compile, incurring\n-- either a dependency or reimplementing it here.\n-- Rather than doing that, we'll use a type signature\n-- of `a -> b` instead.\nforeign import _unsafePartial :: forall a b. a -> b\n\n-- | Discharge a partiality constraint, unsafely.\nunsafePartial :: forall a. (Partial => a) -> a\nunsafePartial = _unsafePartial\n\n-- | A function which crashes with the specified error message.\nunsafeCrashWith :: forall a. String -> a\nunsafeCrashWith msg = unsafePartial (crashWith msg)\n", "module Effect.Aff\n  ( Aff\n  , Fiber\n  , ParAff(..)\n  , Canceler(..)\n  , makeAff\n  , launchAff\n  , launchAff_\n  , launchSuspendedAff\n  , runAff\n  , runAff_\n  , runSuspendedAff\n  , forkAff\n  , suspendAff\n  , supervise\n  , attempt\n  , apathize\n  , delay\n  , never\n  , finally\n  , invincible\n  , killFiber\n  , joinFiber\n  , cancelWith\n  , bracket\n  , BracketConditions\n  , generalBracket\n  , nonCanceler\n  , effectCanceler\n  , fiberCanceler\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow, throwError, catchError, try)\nimport Control.Monad.Error.Class (try, throwError, catchError) as Exports\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Control.Monad.ST.Class (class MonadST, liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Parallel (parSequence_, parallel)\nimport Control.Parallel.Class (class Parallel)\nimport Control.Parallel.Class (sequential, parallel) as Exports\nimport Control.Plus (class Plus, empty)\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried as Fn\nimport Data.Newtype (class Newtype)\nimport Data.Time.Duration (Milliseconds(..))\nimport Data.Time.Duration (Milliseconds(..)) as Exports\nimport Effect (Effect)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Exception (Error, error)\nimport Effect.Exception (Error, error, message) as Exports\nimport Effect.Unsafe (unsafePerformEffect)\nimport Partial.Unsafe (unsafeCrashWith)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An `Aff a` is an asynchronous computation with effects. The\n-- | computation may either error with an exception, or produce a result of\n-- | type `a`. `Aff` effects are assembled from primitive `Effect` effects using\n-- | `makeAff` or `liftEffect`.\nforeign import data Aff :: Type -> Type\n\ntype role Aff representational\n\ninstance functorAff :: Functor Aff where\n  map = _map\n\ninstance applyAff :: Apply Aff where\n  apply = ap\n\ninstance applicativeAff :: Applicative Aff where\n  pure = _pure\n\ninstance bindAff :: Bind Aff where\n  bind = _bind\n\ninstance monadAff :: Monad Aff\n\ninstance semigroupAff :: Semigroup a => Semigroup (Aff a) where\n  append = lift2 append\n\ninstance monoidAff :: Monoid a => Monoid (Aff a) where\n  mempty = pure mempty\n\ninstance altAff :: Alt Aff where\n  alt a1 a2 = catchError a1 (const a2)\n\ninstance plusAff :: Plus Aff where\n  empty = throwError (error \"Always fails\")\n\n-- | This instance is provided for compatibility. `Aff` is always stack-safe\n-- | within a given fiber. This instance will just result in unnecessary\n-- | bind overhead.\ninstance monadRecAff :: MonadRec Aff where\n  tailRecM k = go\n    where\n    go a = do\n      res <- k a\n      case res of\n        Done r -> pure r\n        Loop b -> go b\n\ninstance monadThrowAff :: MonadThrow Error Aff where\n  throwError = _throwError\n\ninstance monadErrorAff :: MonadError Error Aff where\n  catchError = _catchError\n\ninstance monadEffectAff :: MonadEffect Aff where\n  liftEffect = _liftEffect\n\ninstance lazyAff :: Lazy (Aff a) where\n  defer f = pure unit >>= f\n\ninstance monadSTAff :: MonadST Global Aff where\n  liftST = liftST >>> liftEffect\n\n-- | Applicative for running parallel effects. Any `Aff` can be coerced to a\n-- | `ParAff` and back using the `Parallel` class.\nforeign import data ParAff :: Type -> Type\n\ntype role ParAff representational\n\ninstance functorParAff :: Functor ParAff where\n  map = _parAffMap\n\n-- | Runs effects in parallel, combining their results.\ninstance applyParAff :: Apply ParAff where\n  apply = _parAffApply\n\ninstance applicativeParAff :: Applicative ParAff where\n  pure = parallel <<< pure\n\ninstance semigroupParAff :: Semigroup a => Semigroup (ParAff a) where\n  append = lift2 append\n\ninstance monoidParAff :: Monoid a => Monoid (ParAff a) where\n  mempty = pure mempty\n\n-- | Races effects in parallel. Returns the first successful result or the\n-- | first error if all fail with an exception. Losing branches will be\n-- | cancelled.\ninstance altParAff :: Alt ParAff where\n  alt = _parAffAlt\n\ninstance plusParAff :: Plus ParAff where\n  empty = parallel empty\n\ninstance alternativeParAff :: Alternative ParAff\n\ninstance parallelAff :: Parallel ParAff Aff where\n  parallel = (unsafeCoerce :: forall a. Aff a -> ParAff a)\n  sequential = _sequential\n\ntype OnComplete a =\n  { rethrow :: Boolean\n  , handler :: (Either Error a -> Effect Unit) -> Effect Unit\n  }\n\n-- | Represents a forked computation by way of `forkAff`. `Fiber`s are\n-- | memoized, so their results are only computed once.\nnewtype Fiber a = Fiber\n  { run :: Effect Unit\n  , kill :: Fn.Fn2 Error (Either Error Unit -> Effect Unit) (Effect (Effect Unit))\n  , join :: (Either Error a -> Effect Unit) -> Effect (Effect Unit)\n  , onComplete :: OnComplete a -> Effect (Effect Unit)\n  , isSuspended :: Effect Boolean\n  }\n\ninstance functorFiber :: Functor Fiber where\n  map f t = unsafePerformEffect (makeFiber (f <$> joinFiber t))\n\ninstance applyFiber :: Apply Fiber where\n  apply t1 t2 = unsafePerformEffect (makeFiber (joinFiber t1 <*> joinFiber t2))\n\ninstance applicativeFiber :: Applicative Fiber where\n  pure a = unsafePerformEffect (makeFiber (pure a))\n\n-- | Invokes pending cancelers in a fiber and runs cleanup effects. Blocks\n-- | until the fiber has fully exited.\nkillFiber :: forall a. Error -> Fiber a -> Aff Unit\nkillFiber e (Fiber t) = do\n  suspended <- liftEffect t.isSuspended\n  if suspended then\n    liftEffect $ void $ Fn.runFn2 t.kill e (const (pure unit))\n  else\n    makeAff \\k -> effectCanceler <$> Fn.runFn2 t.kill e k\n\n-- | Blocks until the fiber completes, yielding the result. If the fiber\n-- | throws an exception, it is rethrown in the current fiber.\njoinFiber :: Fiber ~> Aff\njoinFiber (Fiber t) = makeAff \\k -> effectCanceler <$> t.join k\n\n-- | A cancellation effect for actions run via `makeAff`. If a `Fiber` is\n-- | killed, and an async action is pending, the canceler will be called to\n-- | clean it up.\nnewtype Canceler = Canceler (Error -> Aff Unit)\n\nderive instance newtypeCanceler :: Newtype Canceler _\n\ninstance semigroupCanceler :: Semigroup Canceler where\n  append (Canceler c1) (Canceler c2) =\n    Canceler \\err -> parSequence_ [ c1 err, c2 err ]\n\n-- | A no-op `Canceler` can be constructed with `mempty`.\ninstance monoidCanceler :: Monoid Canceler where\n  mempty = nonCanceler\n\n-- | A canceler which does not cancel anything.\nnonCanceler :: Canceler\nnonCanceler = Canceler (const (pure unit))\n\n-- | A canceler from an Effect action.\neffectCanceler :: Effect Unit -> Canceler\neffectCanceler = Canceler <<< const <<< liftEffect\n\n-- | A canceler from a Fiber.\nfiberCanceler :: forall a. Fiber a -> Canceler\nfiberCanceler = Canceler <<< flip killFiber\n\n-- | Forks an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchAff aff = do\n  fiber <- makeFiber aff\n  case fiber of Fiber f -> f.run\n  pure fiber\n\n-- | Forks an `Aff` from an `Effect` context, discarding the `Fiber`.\nlaunchAff_ :: Aff Unit -> Effect Unit\nlaunchAff_ = void <<< launchAff\n\n-- | Suspends an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchSuspendedAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchSuspendedAff = makeFiber\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes. Returns the pending `Fiber`.\nrunAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunAff k aff = launchAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes, discarding the `Fiber`.\nrunAff_ :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect Unit\nrunAff_ k aff = void $ runAff k aff\n\n-- | Suspends an `Aff` from an `Effect` context and also takes a callback to run\n-- | when it completes. Returns the suspended `Fiber`.\nrunSuspendedAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunSuspendedAff k aff = launchSuspendedAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from within a parent `Aff` context, returning the `Fiber`.\nforkAff :: forall a. Aff a -> Aff (Fiber a)\nforkAff = _fork true\n\n-- | Suspends an `Aff` from within a parent `Aff` context, returning the `Fiber`.\n-- | A suspended `Aff` is not executed until a consumer observes the result\n-- | with `joinFiber`.\nsuspendAff :: forall a. Aff a -> Aff (Fiber a)\nsuspendAff = _fork false\n\n-- | Pauses the running fiber.\ndelay :: Milliseconds -> Aff Unit\ndelay (Milliseconds n) = Fn.runFn2 _delay Right n\n\n-- | An async computation which does not resolve.\nnever :: forall a. Aff a\nnever = makeAff \\_ -> pure mempty\n\n-- | A monomorphic version of `try`. Catches thrown errors and lifts them\n-- | into an `Either`.\nattempt :: forall a. Aff a -> Aff (Either Error a)\nattempt = try\n\n-- | Ignores any errors.\napathize :: forall a. Aff a -> Aff Unit\napathize = attempt >>> map (const unit)\n\n-- | Runs the first effect after the second, regardless of whether it completed\n-- | successfully or the fiber was cancelled.\nfinally :: forall a. Aff Unit -> Aff a -> Aff a\nfinally fin a = bracket (pure unit) (const fin) (const a)\n\n-- | Runs an effect such that it cannot be killed.\ninvincible :: forall a. Aff a -> Aff a\ninvincible a = bracket a (const (pure unit)) pure\n\n-- | Attaches a custom `Canceler` to an action. If the computation is canceled,\n-- | then the custom `Canceler` will be run afterwards.\ncancelWith :: forall a. Aff a -> Canceler -> Aff a\ncancelWith aff (Canceler cancel) =\n  generalBracket (pure unit)\n    { killed: \\e _ -> cancel e\n    , failed: const pure\n    , completed: const pure\n    }\n    (const aff)\n\n-- | Guarantees resource acquisition and cleanup. The first effect may acquire\n-- | some resource, while the second will dispose of it. The third effect makes\n-- | use of the resource. Disposal is always run last, regardless. Neither\n-- | acquisition nor disposal may be cancelled and are guaranteed to run until\n-- | they complete.\nbracket :: forall a b. Aff a -> (a -> Aff Unit) -> (a -> Aff b) -> Aff b\nbracket acquire completed =\n  generalBracket acquire\n    { killed: const completed\n    , failed: const completed\n    , completed: const completed\n    }\n\ntype Supervised a =\n  { fiber :: Fiber a\n  , supervisor :: Supervisor\n  }\n\n-- | Creates a new supervision context for some `Aff`, guaranteeing fiber\n-- | cleanup when the parent completes. Any pending fibers forked within\n-- | the context will be killed and have their cancelers run.\nsupervise :: forall a. Aff a -> Aff a\nsupervise aff =\n  generalBracket (liftEffect acquire)\n    { killed: \\err sup -> parSequence_ [ killFiber err sup.fiber, killAll err sup ]\n    , failed: const (killAll killError)\n    , completed: const (killAll killError)\n    }\n    (joinFiber <<< _.fiber)\n  where\n  killError :: Error\n  killError =\n    error \"[Aff] Child fiber outlived parent\"\n\n  killAll :: Error -> Supervised a -> Aff Unit\n  killAll err sup = makeAff \\k ->\n    Fn.runFn3 _killAll err sup.supervisor (k (pure unit))\n\n  acquire :: Effect (Supervised a)\n  acquire = do\n    sup <- Fn.runFn2 _makeSupervisedFiber ffiUtil aff\n    case sup.fiber of Fiber f -> f.run\n    pure sup\n\nforeign import data Supervisor :: Type\nforeign import _pure :: forall a. a -> Aff a\nforeign import _throwError :: forall a. Error -> Aff a\nforeign import _catchError :: forall a. Aff a -> (Error -> Aff a) -> Aff a\nforeign import _fork :: forall a. Boolean -> Aff a -> Aff (Fiber a)\nforeign import _map :: forall a b. (a -> b) -> Aff a -> Aff b\nforeign import _bind :: forall a b. Aff a -> (a -> Aff b) -> Aff b\nforeign import _delay :: forall a. Fn.Fn2 (Unit -> Either a Unit) Number (Aff Unit)\nforeign import _liftEffect :: forall a. Effect a -> Aff a\nforeign import _parAffMap :: forall a b. (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffApply :: forall a b. ParAff (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffAlt :: forall a. ParAff a -> ParAff a -> ParAff a\nforeign import _makeFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Fiber a))\nforeign import _makeSupervisedFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Supervised a))\nforeign import _killAll :: Fn.Fn3 Error Supervisor (Effect Unit) (Effect Canceler)\nforeign import _sequential :: ParAff ~> Aff\n\ntype BracketConditions a b =\n  { killed :: Error -> a -> Aff Unit\n  , failed :: Error -> a -> Aff Unit\n  , completed :: b -> a -> Aff Unit\n  }\n\n-- | A general purpose bracket which lets you observe the status of the\n-- | bracketed action. The bracketed action may have been killed with an\n-- | exception, thrown an exception, or completed successfully.\nforeign import generalBracket :: forall a b. Aff a -> BracketConditions a b -> (a -> Aff b) -> Aff b\n\n-- | Constructs an `Aff` from low-level `Effect` effects using a callback. A\n-- | `Canceler` effect should be returned to cancel the pending action. The\n-- | supplied callback may be invoked only once. Subsequent invocation are\n-- | ignored.\nforeign import makeAff :: forall a. ((Either Error a -> Effect Unit) -> Effect Canceler) -> Aff a\n\nmakeFiber :: forall a. Aff a -> Effect (Fiber a)\nmakeFiber aff = Fn.runFn2 _makeFiber ffiUtil aff\n\nnewtype FFIUtil = FFIUtil\n  { isLeft :: forall a b. Either a b -> Boolean\n  , fromLeft :: forall a b. Either a b -> a\n  , fromRight :: forall a b. Either a b -> b\n  , left :: forall a b. a -> Either a b\n  , right :: forall a b. b -> Either a b\n  }\n\nffiUtil :: FFIUtil\nffiUtil = FFIUtil\n  { isLeft\n  , fromLeft: unsafeFromLeft\n  , fromRight: unsafeFromRight\n  , left: Left\n  , right: Right\n  }\n  where\n  isLeft :: forall a b. Either a b -> Boolean\n  isLeft = case _ of\n    Left _ -> true\n    Right _ -> false\n\n  unsafeFromLeft :: forall a b. Either a b -> a\n  unsafeFromLeft = case _ of\n    Left a -> a\n    Right _ -> unsafeCrashWith \"unsafeFromLeft: Right\"\n\n  unsafeFromRight :: forall a b. Either a b -> b\n  unsafeFromRight = case _ of\n    Right a -> a\n    Left _ -> unsafeCrashWith \"unsafeFromRight: Left\"\n", "import core from \"@actions/core\";\nexport const exportVariableImpl = core.exportVariable;\nexport const setSecretImpl = core.setSecret;\nexport const addPathImpl = core.addPath;\nexport const getInput1Impl = core.getInput;\nexport const getInput2Impl = core.getInput;\nexport const setOutputImpl = core.setOutput;\nexport const setCommandEchoImpl = core.setCommandEcho;\nexport const setFailedImpl = core.setFailed;\nexport const isDebugImpl = core.isDebug;\nexport const debugImpl = core.debug;\nexport const errorImpl = core.error;\nexport const warningImpl = core.warning;\nexport const infoImpl = core.info;\nexport const startGroupImpl = core.startGroup;\nexport const endGroupImpl = core.endGroup;\nexport const saveStateImpl = core.saveState;\nexport const getStateImpl = core.getState;\nexport const groupImpl = core.group;\n", "export function promise(f) {\n  return function () {\n    return new Promise(function (success, error) {\n      var succF = function (s) { return function() { return success(s); } };\n      var failF = function (s) { return function() { return error(s); } };\n\n      // This indicates the aff was wrong?\n      try { f(succF)(failF)(); }\n      catch (e) {\n        error(e);\n      }\n    });\n  };\n}\n\nexport function thenImpl(promise) {\n  return function(errCB) {\n    return function(succCB) {\n      return function() {\n        promise.then(succCB, errCB);\n      };\n    };\n  };\n}\n", "\nmodule Control.Monad.Except\n  ( Except\n  , runExcept\n  , mapExcept\n  , withExcept\n  , module Control.Monad.Error.Class\n  , module Control.Monad.Except.Trans\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (class MonadError, catchError, catchJust, throwError)\nimport Control.Monad.Except.Trans (class MonadTrans, ExceptT(..), except, lift, mapExceptT, runExceptT, withExceptT)\n\nimport Data.Either (Either)\nimport Data.Identity (Identity(..))\nimport Data.Newtype (unwrap)\n\n-- | A parametrizable exception monad; computations are either exceptions or\n-- | pure values. If an exception is thrown (see `throwError`), the computation\n-- | terminates with that value. Exceptions may also be caught with `catchError`,\n-- | allowing the computation to resume and exit successfully.\n-- |\n-- | The type parameter `e` is the type of exceptions, and `a` is the type\n-- | of successful results.\n-- |\n-- | A mechanism for trying many different computations until one succeeds is\n-- | provided via the `Alt` instance, specifically the `(<|>)` function.\n-- | The first computation to succeed is returned; if all fail, the exceptions\n-- | are combined using their `Semigroup` instance. The `Plus` instance goes\n-- | further and adds the possibility of a computation failing with an 'empty'\n-- | exception; naturally, this requires the stronger constraint of a `Monoid`\n-- | instance for the exception type.\ntype Except e = ExceptT e Identity\n\n-- | Run a computation in the `Except` monad. The inverse of `except`.\nrunExcept :: forall e a. Except e a -> Either e a\nrunExcept = unwrap <<< runExceptT\n\n-- | Transform the unwrapped computation using the given function.\nmapExcept :: forall e e' a b. (Either e a -> Either e' b) -> Except e a -> Except e' b\nmapExcept f = mapExceptT (Identity <<< f <<< unwrap)\n\n-- | Transform any exceptions thrown by an `Except` computation using the given function.\nwithExcept :: forall e e' a. (e -> e') -> Except e a -> Except e' a\nwithExcept = withExceptT\n", "-- | This module defines a generic non-empty data structure, which adds an\n-- | additional element to any container type.\nmodule Data.NonEmpty\n  ( NonEmpty(..)\n  , singleton\n  , (:|)\n  , foldl1\n  , fromNonEmpty\n  , oneOf\n  , head\n  , tail\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Plus (class Plus, empty)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, foldMap)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldMapWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable (foldl1) as Foldable1\nimport Data.Traversable (class Traversable, traverse, sequence)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (uncurry)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A non-empty container of elements of type a.\n-- |\n-- | ```purescript\n-- | import Data.NonEmpty\n-- |\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = NonEmpty 1 [2,3]\n-- |\n-- | import Data.List(List(..), (:))\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = NonEmpty 1 (2 : 3 : Nil)\n-- | ```\ndata NonEmpty f a = NonEmpty a (f a)\n\n-- | An infix synonym for `NonEmpty`.\n-- |\n-- | ```purescript\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = 1 :| [2,3]\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = 1 :| 2 : 3 : Nil\n-- | ```\ninfixr 5 NonEmpty as :|\n\n-- | Create a non-empty structure with a single value.\n-- |\n-- | ```purescript\n-- | import Prelude\n-- |\n-- | singleton 1 == 1 :| []\n-- | singleton 1 == 1 :| Nil\n-- | ```\nsingleton :: forall f a. Plus f => a -> NonEmpty f a\nsingleton a = a :| empty\n\n-- | Fold a non-empty structure, collecting results using a binary operation.\n-- |\n-- | ```purescript\n-- | foldl1 (+) (1 :| [2, 3]) == 6\n-- | ```\nfoldl1 :: forall f a. Foldable f => (a -> a -> a) -> NonEmpty f a -> a\nfoldl1 = Foldable1.foldl1\n\n-- | Apply a function that takes the `first` element and remaining elements\n-- | as arguments to a non-empty container.\n-- |\n-- | For example, return the remaining elements multiplied by the first element:\n-- |\n-- | ```purescript\n-- | fromNonEmpty (\\x xs -> map (_ * x) xs) (3 :| [2, 1]) == [6, 3]\n-- | ```\nfromNonEmpty :: forall f a r. (a -> f a -> r) -> NonEmpty f a -> r\nfromNonEmpty f (a :| fa) = a `f` fa\n\n-- | Returns the `alt` (`<|>`) result of:\n-- | - The first element lifted to the container of the remaining elements.\n-- | - The remaining elements.\n-- |\n-- | ```purescript\n-- | import Data.Maybe(Maybe(..))\n-- |\n-- | oneOf (1 :| Nothing) == Just 1\n-- | oneOf (1 :| Just 2) == Just 1\n-- |\n-- | oneOf (1 :| [2, 3]) == [1,2,3]\n-- | ```\noneOf :: forall f a. Alternative f => NonEmpty f a -> f a\noneOf (a :| fa) = pure a <|> fa\n\n-- | Get the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | head (1 :| [2, 3]) == 1\n-- | ```\nhead :: forall f a. NonEmpty f a -> a\nhead (x :| _) = x\n\n-- | Get everything but the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | tail (1 :| [2, 3]) == [2, 3]\n-- | ```\ntail :: forall f a. NonEmpty f a -> f a\ntail (_ :| xs) = xs\n\ninstance showNonEmpty :: (Show a, Show (f a)) => Show (NonEmpty f a) where\n  show (a :| fa) = \"(NonEmpty \" <> show a <> \" \" <> show fa <> \")\"\n\nderive instance eqNonEmpty :: (Eq1 f, Eq a) => Eq (NonEmpty f a)\n\nderive instance eq1NonEmpty :: Eq1 f => Eq1 (NonEmpty f)\n\nderive instance ordNonEmpty :: (Ord1 f, Ord a) => Ord (NonEmpty f a)\n\nderive instance ord1NonEmpty :: Ord1 f => Ord1 (NonEmpty f)\n\nderive instance functorNonEmpty :: Functor f => Functor (NonEmpty f)\n\ninstance functorWithIndex\n  :: FunctorWithIndex i f\n  => FunctorWithIndex (Maybe i) (NonEmpty f) where\n  mapWithIndex f (a :| fa) = f Nothing a :| mapWithIndex (f <<< Just) fa\n\ninstance foldableNonEmpty :: Foldable f => Foldable (NonEmpty f) where\n  foldMap f (a :| fa) = f a <> foldMap f fa\n  foldl f b (a :| fa) = foldl f (f b a) fa\n  foldr f b (a :| fa) = f a (foldr f b fa)\n\ninstance foldableWithIndexNonEmpty\n  :: (FoldableWithIndex i f)\n  => FoldableWithIndex (Maybe i) (NonEmpty f) where\n  foldMapWithIndex f (a :| fa) = f Nothing a <> foldMapWithIndex (f <<< Just) fa\n  foldlWithIndex f b (a :| fa) = foldlWithIndex (f <<< Just) (f Nothing b a) fa\n  foldrWithIndex f b (a :| fa) = f Nothing a (foldrWithIndex (f <<< Just) b fa)\n\ninstance traversableNonEmpty :: Traversable f => Traversable (NonEmpty f) where\n  sequence (a :| fa) = NonEmpty <$> a <*> sequence fa\n  traverse f (a :| fa) = NonEmpty <$> f a <*> traverse f fa\n\ninstance traversableWithIndexNonEmpty\n  :: (TraversableWithIndex i f)\n  => TraversableWithIndex (Maybe i) (NonEmpty f) where\n  traverseWithIndex f (a :| fa) =\n    NonEmpty <$> f Nothing a <*> traverseWithIndex (f <<< Just) fa\n\ninstance foldable1NonEmpty :: Foldable f => Foldable1 (NonEmpty f) where\n  foldMap1 f (a :| fa) = foldl (\\s a1 -> s <> f a1) (f a) fa\n  foldr1 f (a :| fa) = maybe a (f a) $ foldr (\\a1 -> Just <<< maybe a1 (f a1)) Nothing fa\n  foldl1 f (a :| fa) = foldl f a fa\n\ninstance unfoldable1NonEmpty :: Unfoldable f => Unfoldable1 (NonEmpty f) where\n  unfoldr1 f b = uncurry (:|) $ unfoldr (map f) <$> f b\n\n-- | This is a lawful `Semigroup` instance that will behave sensibly for common nonempty\n-- | containers like lists and arrays. However, it's not guaranteed that `pure` will behave\n-- | sensibly alongside `<>` for all types, as we don't have any laws which govern their behavior.\ninstance semigroupNonEmpty\n  :: (Applicative f, Semigroup (f a))\n  => Semigroup (NonEmpty f a) where\n  append (a1 :| f1) (a2 :| f2) = a1 :| (f1 <> pure a2 <> f2)\n", "module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) \u2192 foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n", "export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n", "module Data.List.NonEmpty\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n  , fromList\n  , toList\n  , singleton\n  , length\n  , cons\n  , cons'\n  , snoc\n  , snoc'\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , updateAt\n  , modifyAt\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n  , appendFoldable\n  , sort\n  , sortBy\n  , take\n  , takeWhile\n  , drop\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , intersect\n  , intersectBy\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n  , foldM\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.List.Types (NonEmptyList(..))\nimport Data.Maybe (Maybe(..), fromMaybe, maybe)\nimport Data.NonEmpty ((:|))\nimport Data.NonEmpty as NE\nimport Data.Semigroup.Traversable (sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafeCrashWith)\n\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.Semigroup.Foldable (fold1, foldMap1, for1_, sequence1_, traverse1_) as Exports\nimport Data.Semigroup.Traversable (sequence1, traverse1, traverse1Default) as Exports\nimport Data.Traversable (scanl, scanr) as Exports\n\n-- | Internal function: any operation on a list that is guaranteed not to delete\n-- | all elements also applies to a NEL, this function is a helper for defining\n-- | those cases.\nwrappedOperation\n  :: forall a b\n   . String\n  -> (L.List a -> L.List b)\n  -> NonEmptyList a\n  -> NonEmptyList b\nwrappedOperation name f (NonEmptyList (x :| xs)) =\n  case f (x : xs) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Like `wrappedOperation`, but for functions that operate on 2 lists.\nwrappedOperation2\n  :: forall a b c\n   . String\n  -> (L.List a -> L.List b -> L.List c)\n  -> NonEmptyList a\n  -> NonEmptyList b\n  -> NonEmptyList c\nwrappedOperation2 name f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  case f (x : xs) (y : ys) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Lifts a function that operates on a list to work on a NEL. This does not\n-- | preserve the non-empty status of the result.\nlift :: forall a b. (L.List a -> b) -> NonEmptyList a -> b\nlift f (NonEmptyList (x :| xs)) = f (x : xs)\n\ntoUnfoldable :: forall f. Unfoldable f => NonEmptyList ~> f\ntoUnfoldable =\n  unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> L.uncons xs) <<< toList\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyList a)\nfromFoldable = fromList <<< L.fromFoldable\n\nfromList :: forall a. L.List a -> Maybe (NonEmptyList a)\nfromList L.Nil = Nothing\nfromList (x : xs) = Just (NonEmptyList (x :| xs))\n\ntoList :: NonEmptyList ~> L.List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nsingleton :: forall a. a -> NonEmptyList a\nsingleton = NonEmptyList <<< NE.singleton\n\ncons :: forall a. a -> NonEmptyList a -> NonEmptyList a\ncons y (NonEmptyList (x :| xs)) = NonEmptyList (y :| x : xs)\n\ncons' :: forall a. a -> L.List a -> NonEmptyList a\ncons' x xs = NonEmptyList (x :| xs)\n\nsnoc :: forall a. NonEmptyList a -> a -> NonEmptyList a\nsnoc (NonEmptyList (x :| xs)) y = NonEmptyList (x :| L.snoc xs y)\n\nsnoc' :: forall a. L.List a -> a -> NonEmptyList a\nsnoc' (x : xs) y = NonEmptyList (x :| L.snoc xs y)\nsnoc' L.Nil y = singleton y\n\nhead :: forall a. NonEmptyList a -> a\nhead (NonEmptyList (x :| _)) = x\n\nlast :: forall a. NonEmptyList a -> a\nlast (NonEmptyList (x :| xs)) = fromMaybe x (L.last xs)\n\ntail :: NonEmptyList ~> L.List\ntail (NonEmptyList (_ :| xs)) = xs\n\ninit :: NonEmptyList ~> L.List\ninit (NonEmptyList (x :| xs)) = maybe L.Nil (x : _) (L.init xs)\n\nuncons :: forall a. NonEmptyList a -> { head :: a, tail :: L.List a }\nuncons (NonEmptyList (x :| xs)) = { head: x, tail: xs }\n\nunsnoc :: forall a. NonEmptyList a -> { init :: L.List a, last :: a }\nunsnoc (NonEmptyList (x :| xs)) = case L.unsnoc xs of\n  Nothing -> { init: L.Nil, last: x }\n  Just un -> { init: x : un.init, last: un.last }\n\nlength :: forall a. NonEmptyList a -> Int\nlength (NonEmptyList (_ :| xs)) = 1 + L.length xs\n\nindex :: forall a. NonEmptyList a -> Int -> Maybe a\nindex (NonEmptyList (x :| xs)) i\n  | i == 0 = Just x\n  | otherwise = L.index xs (i - 1)\n\ninfixl 8 index as !!\n\nelemIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindIndex f (NonEmptyList (x :| xs))\n  | f x = Just 0\n  | otherwise = (_ + 1) <$> L.findIndex f xs\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindLastIndex f (NonEmptyList (x :| xs)) =\n  case L.findLastIndex f xs of\n    Just i -> Just (i + 1)\n    Nothing\n      | f x -> Just 0\n      | otherwise -> Nothing\n\ninsertAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\ninsertAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| x : xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.insertAt (i - 1) a xs\n\nupdateAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\nupdateAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.updateAt (i - 1) a xs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyList a -> Maybe (NonEmptyList a)\nmodifyAt i f (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (f x :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.modifyAt (i - 1) f xs\n\nreverse :: forall a. NonEmptyList a -> NonEmptyList a\nreverse = wrappedOperation \"reverse\" L.reverse\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\nfilter = lift <<< L.filter\n\nfilterM :: forall m a. Monad m => (a -> m Boolean) -> NonEmptyList a -> m (L.List a)\nfilterM = lift <<< L.filterM\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyList a -> L.List b\nmapMaybe = lift <<< L.mapMaybe\n\ncatMaybes :: forall a. NonEmptyList (Maybe a) -> L.List a\ncatMaybes = lift L.catMaybes\n\nconcat :: forall a. NonEmptyList (NonEmptyList a) -> NonEmptyList a\nconcat = (_ >>= identity)\n\nconcatMap :: forall a b. (a -> NonEmptyList b) -> NonEmptyList a -> NonEmptyList b\nconcatMap = flip bind\n\nappendFoldable :: forall t a. Foldable t => NonEmptyList a -> t a -> NonEmptyList a\nappendFoldable (NonEmptyList (x :| xs)) ys =\n  NonEmptyList (x :| (xs <> L.fromFoldable ys))\n\nsort :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nsort xs = sortBy compare xs\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nsortBy = wrappedOperation \"sortBy\" <<< L.sortBy\n\ntake :: forall a. Int -> NonEmptyList a -> L.List a\ntake = lift <<< L.take\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ntakeWhile = lift <<< L.takeWhile\n\ndrop :: forall a. Int -> NonEmptyList a -> L.List a\ndrop = lift <<< L.drop\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ndropWhile = lift <<< L.dropWhile\n\nspan :: forall a. (a -> Boolean) -> NonEmptyList a -> { init :: L.List a, rest :: L.List a }\nspan = lift <<< L.span\n\ngroup :: forall a. Eq a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroup = wrappedOperation \"group\" L.group\n\ngroupAll :: forall a. Ord a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAll = wrappedOperation \"groupAll\" L.groupAll\n\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupBy = wrappedOperation \"groupBy\" <<< L.groupBy\n\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAllBy = wrappedOperation \"groupAllBy\" <<< L.groupAllBy\n\npartition :: forall a. (a -> Boolean) -> NonEmptyList a -> { yes :: L.List a, no :: L.List a }\npartition = lift <<< L.partition\n\nnub :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nnub = wrappedOperation \"nub\" L.nub\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nnubBy = wrappedOperation \"nubBy\" <<< L.nubBy\n\nnubEq :: forall a. Eq a => NonEmptyList a -> NonEmptyList a\nnubEq = wrappedOperation \"nubEq\" L.nubEq\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a\nnubByEq = wrappedOperation \"nubByEq\" <<< L.nubByEq\n\nunion :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunion = wrappedOperation2 \"union\" L.union\n\nunionBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunionBy = wrappedOperation2 \"unionBy\" <<< L.unionBy\n\nintersect :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersect = wrappedOperation2 \"intersect\" L.intersect\n\nintersectBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersectBy = wrappedOperation2 \"intersectBy\" <<< L.intersectBy\n\nzipWith :: forall a b c. (a -> b -> c) -> NonEmptyList a -> NonEmptyList b -> NonEmptyList c\nzipWith f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  NonEmptyList (f x y :| L.zipWith f xs ys)\n\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> NonEmptyList a -> NonEmptyList b -> m (NonEmptyList c)\nzipWithA f xs ys = sequence1 (zipWith f xs ys)\n\nzip :: forall a b. NonEmptyList a -> NonEmptyList b -> NonEmptyList (Tuple a b)\nzip = zipWith Tuple\n\nunzip :: forall a b. NonEmptyList (Tuple a b) -> Tuple (NonEmptyList a) (NonEmptyList b)\nunzip ts = Tuple (map fst ts) (map snd ts)\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyList a -> m b\nfoldM f b (NonEmptyList (a :| as)) = f b a >>= \\b' -> L.foldM f b' as\n", "-- | This module defines types and functions for working with _foreign_\n-- | data.\n-- |\n-- | `ExceptT (NonEmptyList ForeignError) m` is used in this library\n-- | to encode possible failures when dealing with foreign data.\n-- |\n-- | The `Alt` instance for `ExceptT` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\nmodule Foreign\n  ( Foreign\n  , ForeignError(..)\n  , MultipleErrors(..)\n  , F\n  , FT\n  , renderForeignError\n  , unsafeToForeign\n  , unsafeFromForeign\n  , unsafeReadTagged\n  , typeOf\n  , tagOf\n  , isNull\n  , isUndefined\n  , isArray\n  , readString\n  , readChar\n  , readBoolean\n  , readNumber\n  , readInt\n  , readArray\n  , readNull\n  , readUndefined\n  , readNullOrUndefined\n  , fail\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (Except, ExceptT, mapExceptT, throwError)\nimport Data.Either (Either(..), either)\nimport Data.Int as Int\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.List.NonEmpty as NEL\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.String.CodeUnits (toChar)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A type for _foreign data_.\n-- |\n-- | Foreign data is data from any external _unknown_ or _unreliable_\n-- | source, for which it cannot be guaranteed that the runtime representation\n-- | conforms to that of any particular type.\n-- |\n-- | Suitable applications of `Foreign` are\n-- |\n-- | - To represent responses from web services\n-- | - To integrate with external JavaScript libraries.\nforeign import data Foreign :: Type\n\n-- | A type for foreign type errors\ndata ForeignError\n  = ForeignError String\n  | TypeMismatch String String\n  | ErrorAtIndex Int ForeignError\n  | ErrorAtProperty String ForeignError\n\nderive instance eqForeignError :: Eq ForeignError\nderive instance ordForeignError :: Ord ForeignError\n\ninstance showForeignError :: Show ForeignError where\n  show (ForeignError msg) = \"(ForeignError \" <> show msg <> \")\"\n  show (ErrorAtIndex i e) = \"(ErrorAtIndex \" <> show i <> \" \" <> show e <> \")\"\n  show (ErrorAtProperty prop e) = \"(ErrorAtProperty \" <> show prop <> \" \" <> show e <> \")\"\n  show (TypeMismatch exps act) = \"(TypeMismatch \" <> show exps <> \" \" <> show act <> \")\"\n\n-- | A type for accumulating multiple `ForeignError`s.\ntype MultipleErrors = NonEmptyList ForeignError\n\nrenderForeignError :: ForeignError -> String\nrenderForeignError (ForeignError msg) = msg\nrenderForeignError (ErrorAtIndex i e) = \"Error at array index \" <> show i <> \": \" <> renderForeignError e\nrenderForeignError (ErrorAtProperty prop e) = \"Error at property \" <> show prop <> \": \" <> renderForeignError e\nrenderForeignError (TypeMismatch exp act) = \"Type mismatch: expected \" <> exp <> \", found \" <> act\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `Except (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\n-- |\n-- | An error monad, used in this library to encode possible failures when\n-- | dealing with foreign data.\n-- |\n-- | The `Alt` instance for `Except` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\ntype F = Except MultipleErrors\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `ExceptT (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\ntype FT = ExceptT MultipleErrors\n\n-- | Coerce any value to the a `Foreign` value.\n-- |\n-- | This is considered unsafe as it's only intended to be used on primitive\n-- | JavaScript types, rather than PureScript types. Exporting PureScript values\n-- | via the FFI can be dangerous as they can be mutated by code outside the\n-- | PureScript program, resulting in difficult to diagnose problems elsewhere.\nunsafeToForeign :: forall a. a -> Foreign\nunsafeToForeign = unsafeCoerce\n\n-- | Unsafely coerce a `Foreign` value.\nunsafeFromForeign :: forall a. Foreign -> a\nunsafeFromForeign = unsafeCoerce\n\n-- | Read the Javascript _type_ of a value\nforeign import typeOf :: Foreign -> String\n\n-- | Read the Javascript _tag_ of a value.\n-- |\n-- | This function wraps the `Object.toString` method.\nforeign import tagOf :: Foreign -> String\n\n-- | Unsafely coerce a `Foreign` value when the value has a particular `tagOf`\n-- | value.\nunsafeReadTagged :: forall m a. Monad m => String -> Foreign -> ExceptT (NonEmptyList ForeignError) m a\nunsafeReadTagged tag value\n  | tagOf value == tag = pure (unsafeFromForeign value)\n  | otherwise = fail $ TypeMismatch tag (tagOf value)\n\n-- | Test whether a foreign value is null\nforeign import isNull :: Foreign -> Boolean\n\n-- | Test whether a foreign value is undefined\nforeign import isUndefined :: Foreign -> Boolean\n\n-- | Test whether a foreign value is an array\nforeign import isArray :: Foreign -> Boolean\n\n-- | Attempt to coerce a foreign value to a `String`.\nreadString :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m String\nreadString = unsafeReadTagged \"String\"\n\n-- | Attempt to coerce a foreign value to a `Char`.\nreadChar :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Char\nreadChar value = mapExceptT (map $ either (const error) fromString) (readString value)\n  where\n  fromString = maybe error pure <<< toChar\n  error = Left $ NEL.singleton $ TypeMismatch \"Char\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to a `Boolean`.\nreadBoolean :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Boolean\nreadBoolean = unsafeReadTagged \"Boolean\"\n\n-- | Attempt to coerce a foreign value to a `Number`.\nreadNumber :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Number\nreadNumber = unsafeReadTagged \"Number\"\n\n-- | Attempt to coerce a foreign value to an `Int`.\nreadInt :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Int\nreadInt value = mapExceptT (map $ either (const error) fromNumber) (readNumber value)\n  where\n  fromNumber = maybe error pure <<< Int.fromNumber\n  error = Left $ NEL.singleton $ TypeMismatch \"Int\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to an array.\nreadArray :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Array Foreign)\nreadArray value\n  | isArray value = pure $ unsafeFromForeign value\n  | otherwise = fail $ TypeMismatch \"array\" (tagOf value)\n\nreadNull :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNull value\n  | isNull value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadUndefined value\n  | isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadNullOrUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNullOrUndefined value\n  | isNull value || isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\n-- | Throws a failure error in `ExceptT (NonEmptyList ForeignError) m`.\nfail :: forall m a. Monad m => ForeignError -> ExceptT (NonEmptyList ForeignError) m a\nfail = throwError <<< NEL.singleton\n", "module Control.Promise (fromAff, toAff, toAff', toAffE, Promise()) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Monad.Except (runExcept)\nimport Data.Either (Either(..), either)\nimport Effect (Effect)\nimport Effect.Aff (Aff, makeAff, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (Error, error)\nimport Effect.Uncurried (EffectFn1, mkEffectFn1)\nimport Foreign (Foreign, readString, unsafeReadTagged)\n\n-- | Type of JavaScript Promises (with particular return type)\n-- | Effects are not traced in the Promise type, as they form part of the Effect that\n-- | results in the promise.\nforeign import data Promise :: Type -> Type\n\ntype role Promise representational\n\nforeign import promise :: forall a b.\n  ((a -> Effect Unit) -> (b -> Effect Unit) -> Effect Unit) -> Effect (Promise a)\nforeign import thenImpl :: forall a b.\n  Promise a -> (EffectFn1 Foreign b) -> (EffectFn1 a b) -> Effect Unit\n\n-- | Convert an Aff into a Promise.\nfromAff :: forall a. Aff a -> Effect (Promise a)\nfromAff aff = promise (\\succ err -> runAff_ (either err succ) aff)\n\ncoerce :: Foreign -> Error\ncoerce fn =\n  either (\\_ -> error \"Promise failed, couldn't extract JS Error or String\")\n         identity\n         (runExcept ((unsafeReadTagged \"Error\" fn) <|> (error <$> readString fn)))\n\n-- | Convert a Promise into an Aff.\n-- | When the promise rejects, we attempt to\n-- | coerce the error value into an actual JavaScript Error object. We can do this\n-- | with Error objects or Strings. Anything else gets a \"dummy\" Error object.\ntoAff :: forall a. Promise a -> Aff a\ntoAff = toAff' coerce\n\n-- | Convert a Promise into an Aff with custom Error coercion.\n-- | When the promise rejects, we attempt to coerce the error value into an\n-- | actual JavaScript Error object using the provided function.\ntoAff' :: forall a. (Foreign -> Error) -> Promise a -> Aff a\ntoAff' customCoerce p = makeAff\n  (\\cb -> mempty <$ thenImpl\n    p\n    (mkEffectFn1 $ cb <<< Left <<< customCoerce)\n    (mkEffectFn1 $ cb <<< Right))\n\n-- | Utility to convert an Effect returning a Promise into an Aff (i.e. the inverse of fromAff)\ntoAffE :: forall a. Effect (Promise a) -> Aff a\ntoAffE f = liftEffect f >>= toAff\n", "export const mkEffectFn1 = function mkEffectFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n\nexport const mkEffectFn2 = function mkEffectFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n\nexport const mkEffectFn3 = function mkEffectFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n\nexport const mkEffectFn4 = function mkEffectFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n\nexport const mkEffectFn5 = function mkEffectFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n\nexport const mkEffectFn6 = function mkEffectFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n\nexport const mkEffectFn7 = function mkEffectFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n\nexport const mkEffectFn8 = function mkEffectFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n\nexport const mkEffectFn9 = function mkEffectFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n\nexport const mkEffectFn10 = function mkEffectFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n\nexport const runEffectFn1 = function runEffectFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n\nexport const runEffectFn2 = function runEffectFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n\nexport const runEffectFn3 = function runEffectFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn4 = function runEffectFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn5 = function runEffectFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn6 = function runEffectFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn7 = function runEffectFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn8 = function runEffectFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn9 = function runEffectFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn10 = function runEffectFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "-- | Exports functions from the @actions/core module provided by GitHub\n-- | https://github.com/actions/toolkit/tree/main/packages/core\nmodule GitHub.Actions.Core\n  ( InputOptions\n  , exportVariable\n  , setSecret\n  , addPath\n  , getInput\n  , getInput'\n  , setOutput\n  , setCommandEcho\n  , setFailed\n  , isDebug\n  , debug\n  , error\n  , warning\n  , info\n  , startGroup\n  , endGroup\n  , saveState\n  , getState\n  , group\n  ) where\n\nimport Prelude\nimport Control.Monad.Error.Class (try)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Promise (Promise, fromAff, toAffE)\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff)\nimport Effect.Exception (Error)\nimport Effect.Uncurried (EffectFn1, EffectFn2, runEffectFn1, runEffectFn2)\n\n-- | Interface for getInput options\n-- | required: Whether the input is required. If required and not present, will throw\n-- | required default: false\ntype InputOptions =\n  { required :: Boolean\n  }\n\nforeign import exportVariableImpl :: EffectFn2 String String Unit\n\n-- | Sets env variable for this action and future actions in the job\n-- | name: the name of the variable to set\n-- | val: the value of the variable\nexportVariable :: { key :: String, value :: String } -> Effect Unit\nexportVariable { key, value } = runEffectFn2 exportVariableImpl key value\n\nforeign import setSecretImpl :: EffectFn1 String Unit\n\n-- | Registers a secret which will get masked from logs\nsetSecret :: String -> Effect Unit\nsetSecret = runEffectFn1 setSecretImpl\n\nforeign import addPathImpl :: EffectFn1 String Unit\n\n-- | Prepends input path to the PATH (for this action and future actions)\naddPath :: String -> Effect Unit\naddPath = runEffectFn1 addPathImpl\n\nforeign import getInput1Impl :: EffectFn1 String String\n\nforeign import getInput2Impl :: EffectFn2 String InputOptions String\n\n-- | name: name of the value to get\n-- | options: See InputOptions\ntype GetInputArgs =\n  { name :: String\n  , options :: Maybe InputOptions\n  }\n\n-- | Gets the value of an input.  The value is also trimmed.\n-- | Uses default for options\ngetInput' :: String -> ExceptT Error Effect String\ngetInput' name = getInput { name, options: Nothing }\n\n-- | Gets the value of an input.  The value is also trimmed.\n-- | name: the name of the input to get\n-- | options: See InputOptions\ngetInput :: GetInputArgs -> ExceptT Error Effect String\ngetInput = handleOptions >>> (try >>> ExceptT)\n  where\n  handleOptions { name, options } = case options of\n    Nothing -> runEffectFn1 getInput1Impl name\n    Just opts -> runEffectFn2 getInput2Impl name opts\n\nforeign import setOutputImpl :: EffectFn2 String String Unit\n\n-- | Sets the value of an output.\nsetOutput :: { name :: String, value :: String } -> Effect Unit\nsetOutput { name, value } = runEffectFn2 setOutputImpl name value\n\nforeign import setCommandEchoImpl :: EffectFn1 Boolean Unit\n\n-- | Enables or disables the echoing of commands into stdout for the rest of the step.\nsetCommandEcho :: Boolean -> Effect Unit\nsetCommandEcho = runEffectFn1 setCommandEchoImpl\n\nforeign import setFailedImpl :: EffectFn1 String Unit\n\n-- | Sets the action status to failed.\n-- | When the action exits it will be with an exit code of 1\nsetFailed :: String -> Effect Unit\nsetFailed = runEffectFn1 setFailedImpl\n\nforeign import isDebugImpl :: Effect Boolean\n\n-- | Gets whether Actions Step Debug is on or not\nisDebug :: Effect Boolean\nisDebug = isDebugImpl\n\nforeign import debugImpl :: EffectFn1 String Unit\n\n-- | Writes debug message to user log\ndebug :: String -> Effect Unit\ndebug = runEffectFn1 debugImpl\n\nforeign import errorImpl :: EffectFn1 String Unit\n\n-- | Adds an error issue\nerror :: String -> Effect Unit\nerror = runEffectFn1 errorImpl\n\nforeign import warningImpl :: EffectFn1 String Unit\n\n-- | Adds a warning issue\nwarning :: String -> Effect Unit\nwarning = runEffectFn1 warningImpl\n\nforeign import infoImpl :: EffectFn1 String Unit\n\n-- | Writes info to log with console.log.\ninfo :: String -> Effect Unit\ninfo = runEffectFn1 infoImpl\n\nforeign import startGroupImpl :: EffectFn1 String Unit\n\n-- | Begin an output group.\n-- | Output until the next `groupEnd` will be foldable in this group\nstartGroup :: String -> Effect Unit\nstartGroup = runEffectFn1 startGroupImpl\n\nforeign import endGroupImpl :: Effect Unit\n\n-- | End an output group.\nendGroup :: Effect Unit\nendGroup = endGroupImpl\n\nforeign import saveStateImpl :: EffectFn2 String String Unit\n\n-- | Saves state for current action.\n-- | The state can only be retrieved by this action's post job execution.\nsaveState :: { name :: String, value :: String } -> Effect Unit\nsaveState { name, value } = runEffectFn2 saveStateImpl name value\n\nforeign import getStateImpl :: EffectFn1 String String\n\n-- | Gets the value of an state set by this action's main execution.\ngetState :: String -> Effect String\ngetState = runEffectFn1 getStateImpl\n\nforeign import groupImpl :: forall a. EffectFn2 String (Effect (Promise a)) (Promise a)\n\n-- | Wrap an asynchronous function call in a group.\ngroup :: forall a. { name :: String, fn :: Aff a } -> Aff a\ngroup { name, fn } = toAffE (runEffectFn2 groupImpl name (fromAff fn))\n", "import exec from \"@actions/exec\";\nexport const exec1Impl = exec.exec;\nexport const exec2Impl = exec.exec;\n\nexport function exec2Impl2(command, options) {\n  return exec.exec(command, undefined, options);\n}\n\nexport const exec3Impl = exec.exec;\n", "/* eslint-disable no-eq-null, eqeqeq */\n\nconst nullImpl = null;\nexport { nullImpl as null };\n\nexport function nullable(a, r, f) {\n  return a == null ? r : f(a);\n}\n\nexport function notNull(x) {\n  return x;\n}\n", "-- | This module defines types and functions for working with nullable types\n-- | using the FFI.\n\nmodule Data.Nullable\n  ( Nullable\n  , null\n  , notNull\n  , toMaybe\n  , toNullable\n  ) where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Function (on)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\n\n-- | A nullable type. This type constructor is intended to be used for\n-- | interoperating with JavaScript functions which accept or return null\n-- | values.\n-- |\n-- | The runtime representation of `Nullable T` is the same as that of `T`,\n-- | except that it may also be `null`. For example, the JavaScript values\n-- | `null`, `[]`, and `[1,2,3]` may all be given the type\n-- | `Nullable (Array Int)`. Similarly, the JavaScript values `[]`, `[null]`,\n-- | and `[1,2,null,3]` may all be given the type `Array (Nullable Int)`.\n-- |\n-- | There is one pitfall with `Nullable`, which is that values of the type\n-- | `Nullable T` will not function as you might expect if the type `T` happens\n-- | to itself permit `null` as a valid runtime representation.\n-- |\n-- | In particular, values of the type `Nullable (Nullable T)` will \u2018collapse\u2019,\n-- | in the sense that the PureScript expressions `notNull null` and `null`\n-- | will both leave you with a value whose runtime representation is just\n-- | `null`. Therefore it is important to avoid using `Nullable T` in\n-- | situations where `T` itself can take `null` as a runtime representation.\n-- | If in doubt, use `Maybe` instead.\n-- |\n-- | `Nullable` does not permit lawful `Functor`, `Applicative`, or `Monad`\n-- | instances as a result of this pitfall, which is why these instances are\n-- | not provided.\nforeign import data Nullable :: Type -> Type\n\ntype role Nullable representational\n\n-- | The null value.\nforeign import null :: forall a. Nullable a\n\nforeign import nullable :: forall a r. Fn3 (Nullable a) r (a -> r) r\n\n-- | Wrap a non-null value.\nforeign import notNull :: forall a. a -> Nullable a\n\n-- | Takes `Nothing` to `null`, and `Just a` to `a`.\ntoNullable :: forall a. Maybe a -> Nullable a\ntoNullable = maybe null notNull\n\n-- | Represent `null` using `Maybe a` as `Nothing`. Note that this function\n-- | can violate parametricity, as it inspects the runtime representation of\n-- | its argument (see the warning about the pitfall of `Nullable` above).\ntoMaybe :: forall a. Nullable a -> Maybe a\ntoMaybe n = runFn3 nullable n Nothing Just\n\ninstance showNullable :: Show a => Show (Nullable a) where\n  show = maybe \"null\" show <<< toMaybe\n\ninstance eqNullable :: Eq a => Eq (Nullable a) where\n  eq = eq `on` toMaybe\n\ninstance eq1Nullable :: Eq1 Nullable where\n  eq1 = eq\n\ninstance ordNullable :: Ord a => Ord (Nullable a) where\n  compare = compare `on` toMaybe\n\ninstance ord1Nullable :: Ord1 Nullable where\n  compare1 = compare\n", "-- | Exports functions from the @actions/exec module provided by GitHub\n-- | https://github.com/actions/toolkit/tree/main/packages/exec\nmodule GitHub.Actions.Exec\n  ( exec\n  , exec'\n  , ExecArgs\n  , ExecOptions\n  , defaultExecOptions\n  , ExecListeners\n  , defaultExecListeners\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (try)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Promise (Promise, toAffE)\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (Nullable, toNullable)\nimport Effect (Effect)\nimport Effect.Aff (Aff)\nimport Effect.Exception (Error)\nimport Effect.Uncurried (EffectFn1, EffectFn2, EffectFn3, mkEffectFn1, runEffectFn1, runEffectFn2, runEffectFn3)\nimport Foreign.Object (Object)\nimport Node.Buffer (Buffer)\nimport Node.Stream (Writable)\n\n-- | cwd: working directory.  defaults to current\n-- | env: envvar dictionary.  defaults to current process's env\n-- | silent: defaults to false\n-- | outStream: Defaults to process.stdout\n-- | errStream: Defaults to process.stderr\n-- | windowsVerbatimArguments: whether to skip quoting/escaping arguments if needed.  defaults to false\n-- | failOnStdErr: whether to fail if output to stderr.  defaults to false\n-- | ignoreReturnCode: defaults to failing on non zero.  ignore will not fail leaving it up to the caller\n-- | delay: How long in ms to wait for STDIO streams to close after the exit event of the process before terminating. defaults to 10000\n-- | input: input to write to the process on STDIN\n-- | listeners: Listeners for output. Callback functions that will be called on these events\ntype ExecOptions =\n  { cwd :: Maybe String\n  , env :: Maybe (Object String)\n  , silent :: Maybe Boolean\n  , outStream :: Maybe (Writable ())\n  , errStream :: Maybe (Writable ())\n  , windowsVerbatimArguments :: Maybe Boolean\n  , failOnStdErr :: Maybe Boolean\n  , ignoreReturnCode :: Maybe Boolean\n  , delay :: Maybe Number\n  , input :: Maybe Buffer\n  , listeners :: Maybe ExecListeners\n  }\n\n-- | Defaults for ExecOptions. Override as needed.\ndefaultExecOptions :: ExecOptions\ndefaultExecOptions =\n  { cwd: Nothing\n  , env: Nothing\n  , silent: Nothing\n  , outStream: Nothing\n  , errStream: Nothing\n  , windowsVerbatimArguments: Nothing\n  , failOnStdErr: Nothing\n  , ignoreReturnCode: Nothing\n  , delay: Nothing\n  , input: Nothing\n  , listeners: Nothing\n  }\n\n-- | Listeners for output. Callback functions that will be called on these events\ntype ExecListeners =\n  { stdout :: Maybe (Buffer -> Effect Unit)\n  , stderr :: Maybe (Buffer -> Effect Unit)\n  , stdline :: Maybe (String -> Effect Unit)\n  , errline :: Maybe (String -> Effect Unit)\n  , debug :: Maybe (String -> Effect Unit)\n  }\n\n-- | Defaults for ExecListeners. Override as needed.\ndefaultExecListeners :: ExecListeners\ndefaultExecListeners =\n  { stdout: Nothing\n  , stderr: Nothing\n  , stdline: Nothing\n  , errline: Nothing\n  , debug: Nothing\n  }\n\ntype JSExecOptions =\n  { cwd :: Nullable String\n  , env :: Nullable (Object String)\n  , silent :: Nullable Boolean\n  , outStream :: Nullable (Writable ())\n  , errStream :: Nullable (Writable ())\n  , windowsVerbatimArguments :: Nullable Boolean\n  , failOnStdErr :: Nullable Boolean\n  , ignoreReturnCode :: Nullable Boolean\n  , delay :: Nullable Number\n  , input :: Nullable Buffer\n  , listeners :: Nullable JSExecListeners\n  }\n\ntype JSExecListeners =\n  { stdout :: Nullable (EffectFn1 Buffer Unit)\n  , stderr :: Nullable (EffectFn1 Buffer Unit)\n  , stdline :: Nullable (EffectFn1 String Unit)\n  , errline :: Nullable (EffectFn1 String Unit)\n  , debug :: Nullable (EffectFn1 String Unit)\n  }\n\ntoJSExecOptions :: ExecOptions -> JSExecOptions\ntoJSExecOptions\n  { cwd\n  , env\n  , silent\n  , outStream\n  , errStream\n  , windowsVerbatimArguments\n  , failOnStdErr\n  , ignoreReturnCode\n  , delay\n  , input\n  , listeners\n  } =\n  { cwd: toNullable cwd\n  , env: toNullable env\n  , silent: toNullable silent\n  , outStream: toNullable outStream\n  , errStream: toNullable errStream\n  , windowsVerbatimArguments: toNullable windowsVerbatimArguments\n  , failOnStdErr: toNullable failOnStdErr\n  , ignoreReturnCode: toNullable ignoreReturnCode\n  , delay: toNullable delay\n  , input: toNullable input\n  , listeners: toNullable $ map toJSExecListeners listeners\n  }\n\ntoJSExecListeners :: ExecListeners -> JSExecListeners\ntoJSExecListeners\n  { stdout\n  , stderr\n  , stdline\n  , errline\n  , debug\n  } =\n  { stdout: toNullable $ map mkEffectFn1 stdout\n  , stderr: toNullable $ map mkEffectFn1 stderr\n  , stdline: toNullable $ map mkEffectFn1 stdline\n  , errline: toNullable $ map mkEffectFn1 errline\n  , debug: toNullable $ map mkEffectFn1 debug\n  }\n\nforeign import exec1Impl :: EffectFn1 String (Promise Number)\n\nforeign import exec2Impl :: EffectFn2 String (Array String) (Promise Number)\n\nforeign import exec2Impl2 :: EffectFn2 String JSExecOptions (Promise Number)\n\nforeign import exec3Impl :: EffectFn3 String (Array String) JSExecOptions (Promise Number)\n\n-- | commandLine: command to execute (can include additional args). Must be correctly escaped.\n-- | args: optional arguments for tool. Escaping is handled by the lib. Defaults to empty array.\n-- | options: optional exec options.  See ExecOptions\ntype ExecArgs =\n  { command :: String\n  , args :: Maybe (Array String)\n  , options :: Maybe ExecOptions\n  }\n\n-- | Executes a command on the command line. Uses defaults for args and options\nexec' :: String -> ExceptT Error Aff Number\nexec' command = exec { command, args: Nothing, options: Nothing }\n\n-- | Executes a command on the command line, with arguments\n-- | Output will be streamed to the live console. Provides return code\nexec :: ExecArgs -> ExceptT Error Aff Number\nexec =\n  handleOptions\n    >>> toAffE\n    >>> (try >>> ExceptT)\n  where\n  handleOptions { command, args, options } = case args, options of\n    Nothing, Nothing -> runEffectFn1 exec1Impl command\n    Just a, Nothing -> runEffectFn2 exec2Impl command a\n    Nothing, Just o -> runEffectFn2 exec2Impl2 command (toJSExecOptions o)\n    Just a, Just o -> runEffectFn3 exec3Impl command a (toJSExecOptions o)\n", "export {\n  access as accessImpl,\n  copyFile as copyFileImpl,\n  mkdtemp as mkdtempImpl,\n  rename as renameImpl,\n  truncate as truncateImpl,\n  chown as chownImpl,\n  chmod as chmodImpl,\n  stat as statImpl,\n  lstat as lstatImpl,\n  link as linkImpl,\n  symlink as symlinkImpl,\n  readlink as readlinkImpl,\n  realpath as realpathImpl,\n  unlink as unlinkImpl,\n  rmdir as rmdirImpl,\n  rm as rmImpl,\n  mkdir as mkdirImpl,\n  readdir as readdirImpl,\n  utimes as utimesImpl,\n  readFile as readFileImpl,\n  writeFile as writeFileImpl,\n  appendFile as appendFileImpl,\n  open as openImpl,\n  read as readImpl,\n  write as writeImpl,\n  close as closeImpl\n} from \"node:fs\";\n", "import { constants } from \"node:fs\";\n\nexport const f_OK = constants.F_OK;\n\nexport const r_OK = constants.R_OK;\n\nexport const w_OK = constants.W_OK;\n\nexport const x_OK = constants.X_OK;\n\nexport const copyFile_EXCL = constants.COPYFILE_EXCL;\n\nexport const copyFile_FICLONE = constants.COPYFILE_FICLONE;\n\nexport const copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;\n\nexport const appendCopyMode = (l, r) => l | r;\n", "/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n", "//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n", "function newSTArray() {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just, nothing, i, xs) {\n  return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n};\n\nexport const pokeImpl = function (i, a, xs) {\n  var ret = i >= 0 && i < xs.length;\n  if (ret) xs[i] = a;\n  return ret;\n};\n\nexport const lengthImpl = function (xs) {\n  return xs.length;\n};\n\nexport const popImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.pop()) : nothing;\n};\n\nexport const pushAllImpl = function (as, xs) {\n  return xs.push.apply(xs, as);\n};\n\nexport const shiftImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.shift()) : nothing;\n};\n\nexport const unshiftAllImpl = function (as, xs) {\n  return xs.unshift.apply(xs, as);\n};\n\nexport const spliceImpl = function (i, howMany, bs, xs) {\n  return xs.splice.apply(xs, [i, howMany].concat(bs));\n};\n\nfunction unsafeFreezeThawImpl(xs) {\n  return xs;\n}\n\nexport const unsafeFreezeImpl = unsafeFreezeThawImpl;\n\nexport const unsafeThawImpl = unsafeFreezeThawImpl;\n\nfunction copyImpl(xs) {\n  return xs.slice();\n}\n\nexport const freezeImpl = copyImpl;\n\nexport const thawImpl = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      } else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    if (xs.length < 2) return xs;\n\n    mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n    return xs;\n  };\n})();\n\nexport const toAssocArrayImpl = function (xs) {\n  var n = xs.length;\n  var as = new Array(n);\n  for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n  return as;\n};\n", "module Node.FS.Perms\n  ( Perm\n  , mkPerm\n  , none\n  , read\n  , write\n  , execute\n  , all\n  , Perms\n  , mkPerms\n  , permsAll\n  , permsReadWrite\n  , permsFromString\n  , permsToString\n  , permsToInt\n  ) where\n\nimport Prelude\n\nimport Data.Enum (toEnum)\nimport Data.Int (fromStringAs, octal)\nimport Data.Maybe (Maybe(..), isNothing, fromJust)\nimport Data.String (Pattern(Pattern), joinWith, drop, indexOf)\nimport Data.String.CodeUnits (charAt, toCharArray)\nimport Partial.Unsafe (unsafePartial)\n\n-- | A `Perm` value specifies what is allowed to be done with a particular\n-- | file by a particular class of user &mdash; that is, whether it is\n-- | readable, writable, and/or executable. It has a `Semiring` instance, which\n-- | allows you to combine permissions:\n-- |\n-- | - `(+)` adds `Perm` values together. For example, `read + write` means\n-- |   \"readable and writable\".\n-- | - `(*)` masks permissions. It can be thought of as selecting only the\n-- |    permissions that two `Perm` values have in common. For example:\n-- |    `(read + write) * (write + execute) == write`.\n-- |\n-- | You can think also of a `Perm` value as a subset of the set\n-- | `{ read, write, execute }`; then, `(+)` and `(*)` represent set union and\n-- | intersection respectively.\nnewtype Perm = Perm { r :: Boolean, w :: Boolean, x :: Boolean }\n\ninstance eqPerm :: Eq Perm where\n  eq (Perm { r: r1, w: w1, x: x1 }) (Perm { r: r2, w: w2, x: x2 }) =\n    r1 == r2 && w1 == w2 && x1 == x2\n\ninstance ordPerm :: Ord Perm where\n  compare (Perm { r: r1, w: w1, x: x1 }) (Perm { r: r2, w: w2, x: x2 }) =\n    compare [ r1, w1, x1 ] [ r2, w2, x2 ]\n\ninstance showPerm :: Show Perm where\n  show p | p == none = \"none\"\n  show p | p == all = \"all\"\n  show (Perm { r: r, w: w, x: x }) =\n    joinWith \" + \" ps\n    where\n    ps =\n      (if r then [ \"read\" ] else [])\n        <> (if w then [ \"write\" ] else [])\n        <>\n          (if x then [ \"execute\" ] else [])\n\ninstance semiringPerm :: Semiring Perm where\n  add (Perm { r: r0, w: w0, x: x0 }) (Perm { r: r1, w: w1, x: x1 }) =\n    Perm { r: r0 || r1, w: w0 || w1, x: x0 || x1 }\n  zero = Perm { r: false, w: false, x: false }\n  mul (Perm { r: r0, w: w0, x: x0 }) (Perm { r: r1, w: w1, x: x1 }) =\n    Perm { r: r0 && r1, w: w0 && w1, x: x0 && x1 }\n  one = Perm { r: true, w: true, x: true }\n\n-- | Create a `Perm` value. The arguments represent the readable, writable, and\n-- | executable permissions, in that order.\nmkPerm :: Boolean -> Boolean -> Boolean -> Perm\nmkPerm r w x = Perm { r: r, w: w, x: x }\n\n-- | No permissions. This is the identity of the `Semiring` operation `(+)`\n-- | for `Perm`; that is, it is the same as `zero`.\nnone :: Perm\nnone = zero\n\n-- | The \"readable\" permission.\nread :: Perm\nread = Perm { r: true, w: false, x: false }\n\n-- | The \"writable\" permission.\nwrite :: Perm\nwrite = Perm { r: false, w: true, x: false }\n\n-- | The \"executable\" permission.\nexecute :: Perm\nexecute = Perm { r: false, w: false, x: true }\n\n-- | All permissions: readable, writable, and executable. This is the identity\n-- | of the `Semiring` operation `(*)` for `Perm`; that is, it is the same as\n-- | `one`.\nall :: Perm\nall = one\n\n-- | A `Perms` value includes all the permissions information about a\n-- | particular file or directory, by storing a `Perm` value for each of the\n-- | file owner, the group, and any other users.\nnewtype Perms = Perms { u :: Perm, g :: Perm, o :: Perm }\n\ninstance eqPerms :: Eq Perms where\n  eq (Perms { u: u1, g: g1, o: o1 }) (Perms { u: u2, g: g2, o: o2 }) =\n    u1 == u2 && g1 == g2 && o1 == o2\n\ninstance ordPerms :: Ord Perms where\n  compare (Perms { u: u1, g: g1, o: o1 }) (Perms { u: u2, g: g2, o: o2 }) =\n    compare [ u1, g1, o1 ] [ u2, g2, o2 ]\n\ninstance showPerms :: Show Perms where\n  show (Perms { u: u, g: g, o: o }) =\n    \"mkPerms \" <> joinWith \" \" (f <$> [ u, g, o ])\n    where\n    f perm =\n      let\n        str = show perm\n      in\n        if isNothing $ indexOf (Pattern \" \") str then str\n        else \"(\" <> str <> \")\"\n\n-- | Attempt to parse a `Perms` value from a `String` containing an octal\n-- | integer. For example,\n-- | `permsFromString \"0644\" == Just (mkPerms (read + write) read read)`.\npermsFromString :: String -> Maybe Perms\npermsFromString = _perms <<< toCharArray <<< dropPrefix zeroChar\n  where\n  zeroChar = unsafePartial $ fromJust $ toEnum 48\n\n  dropPrefix x xs\n    | charAt 0 xs == Just x = drop 1 xs\n    | otherwise = xs\n\n  _perms [ u, g, o ] =\n    mkPerms <$> permFromChar u\n      <*> permFromChar g\n      <*> permFromChar o\n  _perms _ = Nothing\n\npermFromChar :: Char -> Maybe Perm\npermFromChar c = case c of\n  '0' -> Just $ none\n  '1' -> Just $ execute\n  '2' -> Just $ write\n  '3' -> Just $ write + execute\n  '4' -> Just $ read\n  '5' -> Just $ read + execute\n  '6' -> Just $ read + write\n  '7' -> Just $ read + write + execute\n  _ -> Nothing\n\n-- | Create a `Perms` value. The arguments represent the owner's, group's, and\n-- | other users' permission sets, respectively.\nmkPerms :: Perm -> Perm -> Perm -> Perms\nmkPerms u g o = Perms { u: u, g: g, o: o }\n\npermsAll :: Perms\npermsAll = mkPerms all all all\n\npermsReadWrite :: Perms\npermsReadWrite = mkPerms all all none\n\n-- | Convert a `Perm` to an octal digit. For example:\n-- |\n-- | * `permToInt r == 4`\n-- | * `permToInt w == 2`\n-- | * `permToInt (r + w) == 6`\npermToInt :: Perm -> Int\npermToInt (Perm { r: r, w: w, x: x }) =\n  (if r then 4 else 0)\n    + (if w then 2 else 0)\n    + (if x then 1 else 0)\n\n-- | Convert a `Perm` to an octal string, via `permToInt`.\npermToString :: Perm -> String\npermToString = show <<< permToInt\n\n-- | Convert a `Perms` value to an octal string, in a format similar to that\n-- | accepted by `chmod`. For example:\n-- | `permsToString (mkPerms (read + write) read read) == \"0644\"`\npermsToString :: Perms -> String\npermsToString (Perms { u: u, g: g, o: o }) =\n  \"0\"\n    <> permToString u\n    <> permToString g\n    <> permToString o\n\n-- | Convert a `Perms` value to an `Int`, via `permsToString`.\npermsToInt :: Perms -> Int\npermsToInt = unsafePartial $ fromJust <<< fromStringAs octal <<< permsToString\n", "module Node.FS.Async\n  ( Callback(..)\n  , access\n  , access'\n  , copyFile\n  , copyFile'\n  , mkdtemp\n  , mkdtemp'\n  , rename\n  , truncate\n  , chown\n  , chmod\n  , lstat\n  , stat\n  , link\n  , symlink\n  , readlink\n  , realpath\n  , realpath'\n  , unlink\n  , rmdir\n  , rmdir'\n  , rm\n  , rm'\n  , mkdir\n  , mkdir'\n  , readdir\n  , utimes\n  , readFile\n  , readTextFile\n  , writeFile\n  , writeTextFile\n  , appendFile\n  , appendTextFile\n  , fdOpen\n  , fdRead\n  , fdNext\n  , fdWrite\n  , fdAppend\n  , fdClose\n  ) where\n\nimport Prelude\n\nimport Data.DateTime (DateTime)\nimport Data.DateTime.Instant (fromDateTime, unInstant)\nimport Data.Either (Either(..))\nimport Data.Int (round)\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (Nullable, toMaybe, toNullable)\nimport Data.Time.Duration (Milliseconds(..))\nimport Effect (Effect)\nimport Effect.Exception (Error)\nimport Effect.Uncurried (EffectFn1, EffectFn2, EffectFn3, EffectFn4, EffectFn6, mkEffectFn1, mkEffectFn2, runEffectFn2, runEffectFn3, runEffectFn4, runEffectFn6)\nimport Node.Buffer (Buffer, size)\nimport Node.Encoding (Encoding(..), encodingToNode)\nimport Node.FS (FileDescriptor, ByteCount, FilePosition, BufferLength, BufferOffset, FileMode, SymlinkType, symlinkTypeToNode)\nimport Node.FS.Constants (FileFlags, fileFlagsToNode, AccessMode, CopyMode, defaultAccessMode, defaultCopyMode)\nimport Node.FS.Perms (Perms, permsToString, all, mkPerms)\nimport Node.FS.Stats (StatsObj, Stats(..))\nimport Node.Path (FilePath)\n\ntype JSCallback a = EffectFn2 (Nullable Error) a Unit\n\nhandleCallback :: forall a. Callback a -> JSCallback a\nhandleCallback cb = mkEffectFn2 \\err a -> case toMaybe err of\n  Nothing -> cb (Right a)\n  Just err' -> cb (Left err')\n\n-- | Type synonym for callback functions.\ntype Callback a = Either Error a -> Effect Unit\n\naccess :: FilePath -> (Maybe Error -> Effect Unit) -> Effect Unit\naccess path = access' path defaultAccessMode\n\naccess' :: FilePath -> AccessMode -> (Maybe Error -> Effect Unit) -> Effect Unit\naccess' path mode cb = runEffectFn3 accessImpl path mode $ mkEffectFn1 \\err -> do\n  cb $ toMaybe err\n\nforeign import accessImpl :: EffectFn3 FilePath AccessMode (EffectFn1 (Nullable Error) Unit) Unit\n\ncopyFile :: FilePath -> FilePath -> Callback Unit -> Effect Unit\ncopyFile src dest = copyFile' src dest defaultCopyMode\n\ncopyFile' :: FilePath -> FilePath -> CopyMode -> Callback Unit -> Effect Unit\ncopyFile' src dest mode cb = runEffectFn4 copyFileImpl src dest mode (handleCallback cb)\n\nforeign import copyFileImpl :: EffectFn4 FilePath FilePath CopyMode (JSCallback Unit) Unit\n\nmkdtemp :: String -> Callback String -> Effect Unit\nmkdtemp prefix = mkdtemp' prefix UTF8\n\nmkdtemp' :: String -> Encoding -> Callback String -> Effect Unit\nmkdtemp' prefix encoding cb = runEffectFn3 mkdtempImpl prefix (encodingToNode encoding) (handleCallback cb)\n\nforeign import mkdtempImpl :: EffectFn3 FilePath String (JSCallback String) Unit\n\nforeign import renameImpl :: EffectFn3 FilePath FilePath (JSCallback Unit) Unit\nforeign import truncateImpl :: EffectFn3 FilePath Int (JSCallback Unit) Unit\nforeign import chownImpl :: EffectFn4 FilePath Int Int (JSCallback Unit) Unit\nforeign import chmodImpl :: EffectFn3 FilePath String (JSCallback Unit) Unit\nforeign import statImpl :: EffectFn2 FilePath (JSCallback StatsObj) Unit\nforeign import lstatImpl :: EffectFn2 FilePath (JSCallback StatsObj) Unit\nforeign import linkImpl :: EffectFn3 FilePath FilePath (JSCallback Unit) Unit\nforeign import symlinkImpl :: EffectFn4 FilePath FilePath String (JSCallback Unit) Unit\nforeign import readlinkImpl :: EffectFn2 FilePath (JSCallback FilePath) Unit\nforeign import realpathImpl :: forall cache. EffectFn3 FilePath { | cache } (JSCallback FilePath) Unit\nforeign import unlinkImpl :: EffectFn2 FilePath (JSCallback Unit) Unit\nforeign import rmdirImpl :: EffectFn3 FilePath { maxRetries :: Int, retryDelay :: Int } (JSCallback Unit) Unit\nforeign import rmImpl :: EffectFn3 FilePath { force :: Boolean, maxRetries :: Int, recursive :: Boolean, retryDelay :: Int } (JSCallback Unit) Unit\nforeign import mkdirImpl :: EffectFn3 FilePath { recursive :: Boolean, mode :: String } (JSCallback Unit) Unit\nforeign import readdirImpl :: EffectFn2 FilePath (JSCallback (Array FilePath)) Unit\nforeign import utimesImpl :: EffectFn4 FilePath Int Int (JSCallback Unit) Unit\nforeign import readFileImpl :: forall a opts. EffectFn3 FilePath { | opts } (JSCallback a) Unit\nforeign import writeFileImpl :: forall a opts. EffectFn4 FilePath a { | opts } (JSCallback Unit) Unit\nforeign import appendFileImpl :: forall a opts. EffectFn4 FilePath a { | opts } (JSCallback Unit) Unit\nforeign import openImpl :: EffectFn4 FilePath String (Nullable FileMode) (JSCallback FileDescriptor) Unit\nforeign import readImpl :: EffectFn6 FileDescriptor Buffer BufferOffset BufferLength (Nullable FilePosition) (JSCallback ByteCount) Unit\nforeign import writeImpl :: EffectFn6 FileDescriptor Buffer BufferOffset BufferLength (Nullable FilePosition) (JSCallback ByteCount) Unit\nforeign import closeImpl :: EffectFn2 FileDescriptor (JSCallback Unit) Unit\n\n-- | Renames a file.\nrename\n  :: FilePath\n  -> FilePath\n  -> Callback Unit\n  -> Effect Unit\nrename oldFile newFile cb = runEffectFn3 renameImpl oldFile newFile (handleCallback cb)\n\n-- | Truncates a file to the specified length.\ntruncate\n  :: FilePath\n  -> Int\n  -> Callback Unit\n  -> Effect Unit\ntruncate file len cb = runEffectFn3 truncateImpl file len (handleCallback cb)\n\n-- | Changes the ownership of a file.\nchown\n  :: FilePath\n  -> Int\n  -> Int\n  -> Callback Unit\n  -> Effect Unit\nchown file uid gid cb = runEffectFn4 chownImpl file uid gid (handleCallback cb)\n\n-- | Changes the permissions of a file.\nchmod\n  :: FilePath\n  -> Perms\n  -> Callback Unit\n  -> Effect Unit\nchmod file perms cb = runEffectFn3 chmodImpl file (permsToString perms) (handleCallback cb)\n\n-- | Gets file statistics.\nstat\n  :: FilePath\n  -> Callback Stats\n  -> Effect Unit\nstat file cb = runEffectFn2 statImpl file (handleCallback $ cb <<< map Stats)\n\n-- | Gets file or symlink statistics. `lstat` is identical to `stat`, except\n-- | that if the\u00A0`FilePath` is a symbolic link, then the link itself is stat-ed,\n-- | not the file that it refers to.\nlstat\n  :: FilePath\n  -> Callback Stats\n  -> Effect Unit\nlstat file cb = runEffectFn2 lstatImpl file (handleCallback $ cb <<< map Stats)\n\n-- | Creates a link to an existing file.\nlink\n  :: FilePath\n  -> FilePath\n  -> Callback Unit\n  -> Effect Unit\nlink src dst cb = runEffectFn3 linkImpl src dst (handleCallback cb)\n\n-- | Creates a symlink.\nsymlink\n  :: FilePath\n  -> FilePath\n  -> SymlinkType\n  -> Callback Unit\n  -> Effect Unit\nsymlink src dest ty cb = runEffectFn4 symlinkImpl src dest (symlinkTypeToNode ty) (handleCallback cb)\n\n-- | Reads the value of a symlink.\nreadlink\n  :: FilePath\n  -> Callback FilePath\n  -> Effect Unit\nreadlink path cb = runEffectFn2 readlinkImpl path (handleCallback cb)\n\n-- | Find the canonicalized absolute location for a path.\nrealpath\n  :: FilePath\n  -> Callback FilePath\n  -> Effect Unit\nrealpath path cb = runEffectFn3 realpathImpl path {} (handleCallback cb)\n\n-- | Find the canonicalized absolute location for a path using a cache object\n-- | for already resolved paths.\nrealpath'\n  :: forall cache\n   . FilePath\n  -> { | cache }\n  -> Callback FilePath\n  -> Effect Unit\nrealpath' path cache cb = runEffectFn3 realpathImpl path cache (handleCallback cb)\n\n-- | Deletes a file.\nunlink\n  :: FilePath\n  -> Callback Unit\n  -> Effect Unit\nunlink file cb = runEffectFn2 unlinkImpl file (handleCallback cb)\n\n-- | Deletes a directory.\nrmdir\n  :: FilePath\n  -> Callback Unit\n  -> Effect Unit\nrmdir path cb = rmdir' path { maxRetries: 0, retryDelay: 100 } cb\n\n-- | Deletes a directory with options.\nrmdir'\n  :: FilePath\n  -> { maxRetries :: Int, retryDelay :: Int }\n  -> Callback Unit\n  -> Effect Unit\nrmdir' path opts cb = runEffectFn3 rmdirImpl path opts (handleCallback cb)\n\n-- | Deletes a file or directory.\nrm\n  :: FilePath\n  -> Callback Unit\n  -> Effect Unit\nrm path = rm' path { force: false, maxRetries: 100, recursive: false, retryDelay: 1000 }\n\n-- | Deletes a file or directory with options.\nrm'\n  :: FilePath\n  -> { force :: Boolean, maxRetries :: Int, recursive :: Boolean, retryDelay :: Int }\n  -> Callback Unit\n  -> Effect Unit\nrm' path opts cb = runEffectFn3 rmImpl path opts (handleCallback cb)\n\n-- | Makes a new directory.\nmkdir\n  :: FilePath\n  -> Callback Unit\n  -> Effect Unit\nmkdir path = mkdir' path { recursive: false, mode: mkPerms all all all }\n\n-- | Makes a new directory with the specified permissions.\nmkdir'\n  :: FilePath\n  -> { recursive :: Boolean, mode :: Perms }\n  -> Callback Unit\n  -> Effect Unit\nmkdir' file { recursive, mode: perms } cb = runEffectFn3 mkdirImpl file { recursive, mode: permsToString perms } (handleCallback cb)\n\n-- | Reads the contents of a directory.\nreaddir\n  :: FilePath\n  -> Callback (Array FilePath)\n  -> Effect Unit\nreaddir file cb = runEffectFn2 readdirImpl file (handleCallback cb)\n\n-- | Sets the accessed and modified times for the specified file.\nutimes\n  :: FilePath\n  -> DateTime\n  -> DateTime\n  -> Callback Unit\n  -> Effect Unit\nutimes file atime mtime cb = runEffectFn4 utimesImpl file (fromDate atime) (fromDate mtime) (handleCallback cb)\n  where\n  fromDate date = ms (toEpochMilliseconds date) / 1000\n  ms (Milliseconds n) = round n\n  toEpochMilliseconds = unInstant <<< fromDateTime\n\n-- | Reads the entire contents of a file returning the result as a raw buffer.\nreadFile\n  :: FilePath\n  -> Callback Buffer\n  -> Effect Unit\nreadFile file cb = runEffectFn3 readFileImpl file {} (handleCallback cb)\n\n-- | Reads the entire contents of a text file with the specified encoding.\nreadTextFile\n  :: Encoding\n  -> FilePath\n  -> Callback String\n  -> Effect Unit\nreadTextFile encoding file cb = runEffectFn3 readFileImpl file { encoding: show encoding } (handleCallback cb)\n\n-- | Writes a buffer to a file.\nwriteFile\n  :: FilePath\n  -> Buffer\n  -> Callback Unit\n  -> Effect Unit\nwriteFile file buff cb = runEffectFn4 writeFileImpl file buff {} (handleCallback cb)\n\n-- | Writes text to a file using the specified encoding.\nwriteTextFile\n  :: Encoding\n  -> FilePath\n  -> String\n  -> Callback Unit\n  -> Effect Unit\nwriteTextFile encoding file buff cb = runEffectFn4 writeFileImpl file buff { encoding: show encoding } (handleCallback cb)\n\n-- | Appends the contents of a buffer to a file.\nappendFile\n  :: FilePath\n  -> Buffer\n  -> Callback Unit\n  -> Effect Unit\nappendFile file buff cb = runEffectFn4 appendFileImpl file buff {} (handleCallback cb)\n\n-- | Appends text to a file using the specified encoding.\nappendTextFile\n  :: Encoding\n  -> FilePath\n  -> String\n  -> Callback Unit\n  -> Effect Unit\nappendTextFile encoding file buff cb = runEffectFn4 appendFileImpl file buff { encoding: show encoding } (handleCallback cb)\n\n-- | Open a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback)\n-- | for details.\nfdOpen\n  :: FilePath\n  -> FileFlags\n  -> Maybe FileMode\n  -> Callback FileDescriptor\n  -> Effect Unit\nfdOpen file flags mode cb = runEffectFn4 openImpl file (fileFlagsToNode flags) (toNullable mode) (handleCallback cb)\n\n-- | Read from a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback)\n-- | for details.\nfdRead\n  :: FileDescriptor\n  -> Buffer\n  -> BufferOffset\n  -> BufferLength\n  -> Maybe FilePosition\n  -> Callback ByteCount\n  -> Effect Unit\nfdRead fd buff off len pos cb = runEffectFn6 readImpl fd buff off len (toNullable pos) (handleCallback cb)\n\n-- | Convenience function to fill the whole buffer from the current\n-- | file position.\nfdNext\n  :: FileDescriptor\n  -> Buffer\n  -> Callback ByteCount\n  -> Effect Unit\nfdNext fd buff cb = do\n  sz <- size buff\n  fdRead fd buff 0 sz Nothing cb\n\n-- | Write to a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback)\n-- | for details.\nfdWrite\n  :: FileDescriptor\n  -> Buffer\n  -> BufferOffset\n  -> BufferLength\n  -> Maybe FilePosition\n  -> Callback ByteCount\n  -> Effect Unit\nfdWrite fd buff off len pos cb = runEffectFn6 writeImpl fd buff off len (toNullable pos) (handleCallback cb)\n\n-- | Convenience function to append the whole buffer to the current\n-- | file position.\nfdAppend\n  :: FileDescriptor\n  -> Buffer\n  -> Callback ByteCount\n  -> Effect Unit\nfdAppend fd buff cb = do\n  sz <- size buff\n  fdWrite fd buff 0 sz Nothing cb\n\n-- | Close a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_close_fd_callback)\n-- | for details.\nfdClose\n  :: FileDescriptor\n  -> Callback Unit\n  -> Effect Unit\nfdClose fd cb = runEffectFn2 closeImpl fd (handleCallback cb)\n", "module Node.FS.Aff\n  ( access\n  , access'\n  , copyFile\n  , copyFile'\n  , mkdtemp\n  , mkdtemp'\n  , rename\n  , truncate\n  , chown\n  , chmod\n  , stat\n  , link\n  , symlink\n  , readlink\n  , realpath\n  , realpath'\n  , unlink\n  , rmdir\n  , rmdir'\n  , rm\n  , rm'\n  , mkdir\n  , mkdir'\n  , readdir\n  , utimes\n  , readFile\n  , readTextFile\n  , writeFile\n  , writeTextFile\n  , appendFile\n  , appendTextFile\n  , fdOpen\n  , fdRead\n  , fdNext\n  , fdWrite\n  , fdAppend\n  , fdClose\n  ) where\n\nimport Prelude\n\nimport Data.DateTime (DateTime)\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe)\nimport Effect (Effect)\nimport Effect.Aff (Aff, Error, makeAff, nonCanceler)\nimport Node.Buffer (Buffer)\nimport Node.Encoding (Encoding)\nimport Node.FS as F\nimport Node.FS.Async as A\nimport Node.FS.Constants (AccessMode, CopyMode)\nimport Node.FS.Perms (Perms)\nimport Node.FS.Stats (Stats)\nimport Node.Path (FilePath)\n\ntoAff\n  :: forall a\n   . (A.Callback a -> Effect Unit)\n  -> Aff a\ntoAff p = makeAff \\k -> p k $> nonCanceler\n\ntoAff1\n  :: forall a x\n   . (x -> A.Callback a -> Effect Unit)\n  -> x\n  -> Aff a\ntoAff1 f a = toAff (f a)\n\ntoAff2\n  :: forall a x y\n   . (x -> y -> A.Callback a -> Effect Unit)\n  -> x\n  -> y\n  -> Aff a\ntoAff2 f a b = toAff (f a b)\n\ntoAff3\n  :: forall a x y z\n   . (x -> y -> z -> A.Callback a -> Effect Unit)\n  -> x\n  -> y\n  -> z\n  -> Aff a\ntoAff3 f a b c = toAff (f a b c)\n\ntoAff5\n  :: forall a w v x y z\n   . (w -> v -> x -> y -> z -> A.Callback a -> Effect Unit)\n  -> w\n  -> v\n  -> x\n  -> y\n  -> z\n  -> Aff a\ntoAff5 f a b c d e = toAff (f a b c d e)\n\naccess :: String -> Aff (Maybe Error)\naccess path = makeAff \\k -> do\n  A.access path (k <<< Right)\n  pure nonCanceler\n\naccess' :: String -> AccessMode -> Aff (Maybe Error)\naccess' path mode = makeAff \\k -> do\n  A.access' path mode (k <<< Right)\n  pure nonCanceler\n\ncopyFile :: String -> String -> Aff Unit\ncopyFile = toAff2 A.copyFile\n\ncopyFile' :: String -> String -> CopyMode -> Aff Unit\ncopyFile' = toAff3 A.copyFile'\n\nmkdtemp :: String -> Aff String\nmkdtemp = toAff1 A.mkdtemp\n\nmkdtemp' :: String -> Encoding -> Aff String\nmkdtemp' = toAff2 A.mkdtemp'\n\n-- |\n-- | Rename a file.\n-- |\nrename :: FilePath -> FilePath -> Aff Unit\nrename = toAff2 A.rename\n\n-- |\n-- | Truncates a file to the specified length.\n-- |\ntruncate :: FilePath -> Int -> Aff Unit\ntruncate = toAff2 A.truncate\n\n-- |\n-- | Changes the ownership of a file.\n-- |\nchown :: FilePath -> Int -> Int -> Aff Unit\nchown = toAff3 A.chown\n\n-- |\n-- | Changes the permissions of a file.\n-- |\nchmod :: FilePath -> Perms -> Aff Unit\nchmod = toAff2 A.chmod\n\n-- |\n-- | Gets file statistics.\n-- |\nstat :: FilePath -> Aff Stats\nstat = toAff1 A.stat\n\n-- |\n-- | Creates a link to an existing file.\n-- |\nlink :: FilePath -> FilePath -> Aff Unit\nlink = toAff2 A.link\n\n-- |\n-- | Creates a symlink.\n-- |\nsymlink\n  :: FilePath\n  -> FilePath\n  -> F.SymlinkType\n  -> Aff Unit\nsymlink = toAff3 A.symlink\n\n-- |\n-- | Reads the value of a symlink.\n-- |\nreadlink :: FilePath -> Aff FilePath\nreadlink = toAff1 A.readlink\n\n-- |\n-- | Find the canonicalized absolute location for a path.\n-- |\nrealpath :: FilePath -> Aff FilePath\nrealpath = toAff1 A.realpath\n\n-- |\n-- | Find the canonicalized absolute location for a path using a cache object\n-- | for already resolved paths.\n-- |\nrealpath' :: forall cache. FilePath -> { | cache } -> Aff FilePath\nrealpath' = toAff2 A.realpath'\n\n-- |\n-- | Deletes a file.\n-- |\nunlink :: FilePath -> Aff Unit\nunlink = toAff1 A.unlink\n\n-- |\n-- | Deletes a directory.\n-- |\nrmdir :: FilePath -> Aff Unit\nrmdir = toAff1 A.rmdir\n\n-- |\n-- | Deletes a directory with options.\n-- |\nrmdir' :: FilePath -> { maxRetries :: Int, retryDelay :: Int } -> Aff Unit\nrmdir' = toAff2 A.rmdir'\n\n-- |\n-- | Deletes a file or directory.\n-- |\nrm :: FilePath -> Aff Unit\nrm = toAff1 A.rmdir\n\n-- |\n-- | Deletes a file or directory with options.\n-- |\nrm' :: FilePath -> { force :: Boolean, maxRetries :: Int, recursive :: Boolean, retryDelay :: Int } -> Aff Unit\nrm' = toAff2 A.rm'\n\n-- |\n-- | Makes a new directory.\n-- |\nmkdir :: FilePath -> Aff Unit\nmkdir = toAff1 A.mkdir\n\n-- |\n-- | Makes a new directory with all of its options.\n-- |\nmkdir' :: FilePath -> { recursive :: Boolean, mode :: Perms } -> Aff Unit\nmkdir' = toAff2 A.mkdir'\n\n-- |\n-- | Reads the contents of a directory.\n-- |\nreaddir :: FilePath -> Aff (Array FilePath)\nreaddir = toAff1 A.readdir\n\n-- |\n-- | Sets the accessed and modified times for the specified file.\n-- |\nutimes :: FilePath -> DateTime -> DateTime -> Aff Unit\nutimes = toAff3 A.utimes\n\n-- |\n-- | Reads the entire contents of a file returning the result as a raw buffer.\n-- |\nreadFile :: FilePath -> Aff Buffer\nreadFile = toAff1 A.readFile\n\n-- |\n-- | Reads the entire contents of a text file with the specified encoding.\n-- |\nreadTextFile :: Encoding -> FilePath -> Aff String\nreadTextFile = toAff2 A.readTextFile\n\n-- |\n-- | Writes a buffer to a file.\n-- |\nwriteFile :: FilePath -> Buffer -> Aff Unit\nwriteFile = toAff2 A.writeFile\n\n-- |\n-- | Writes text to a file using the specified encoding.\n-- |\nwriteTextFile :: Encoding -> FilePath -> String -> Aff Unit\nwriteTextFile = toAff3 A.writeTextFile\n\n-- |\n-- | Appends the contents of a buffer to a file.\n-- |\nappendFile :: FilePath -> Buffer -> Aff Unit\nappendFile = toAff2 A.appendFile\n\n-- |\n-- | Appends text to a file using the specified encoding.\n-- |\nappendTextFile :: Encoding -> FilePath -> String -> Aff Unit\nappendTextFile = toAff3 A.appendTextFile\n\n-- | Open a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback)\n-- | for details.\nfdOpen\n  :: FilePath\n  -> F.FileFlags\n  -> Maybe F.FileMode\n  -> Aff F.FileDescriptor\nfdOpen = toAff3 A.fdOpen\n\n-- | Read from a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback)\n-- | for details.\nfdRead\n  :: F.FileDescriptor\n  -> Buffer\n  -> F.BufferOffset\n  -> F.BufferLength\n  -> Maybe F.FilePosition\n  -> Aff F.ByteCount\nfdRead = toAff5 A.fdRead\n\n-- | Convenience function to fill the whole buffer from the current\n-- | file position.\nfdNext :: F.FileDescriptor -> Buffer -> Aff F.ByteCount\nfdNext = toAff2 A.fdNext\n\n-- | Write to a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback)\n-- | for details.\nfdWrite\n  :: F.FileDescriptor\n  -> Buffer\n  -> F.BufferOffset\n  -> F.BufferLength\n  -> Maybe F.FilePosition\n  -> Aff F.ByteCount\nfdWrite = toAff5 A.fdWrite\n\n-- | Convenience function to append the whole buffer to the current\n-- | file position.\nfdAppend :: F.FileDescriptor -> Buffer -> Aff F.ByteCount\nfdAppend = toAff2 A.fdAppend\n\n-- | Close a file asynchronously. See the [Node Documentation](https://nodejs.org/api/fs.html#fs_fs_close_fd_callback)\n-- | for details.\nfdClose :: F.FileDescriptor -> Aff Unit\nfdClose = toAff1 A.fdClose\n", "import path from \"path\";\nexport const normalize = path.normalize;\n\nexport function concat(segments) {\n  return path.join.apply(this, segments);\n}\n\nexport function resolve(from) {\n  return to => () => path.resolve.apply(this, from.concat([to]));\n}\n\nexport function relative(from) {\n  return to => path.relative(from, to);\n}\n\nexport function dirname(p) {\n  return path.normalize(path.dirname(p));\n}\n\nexport const basename = path.basename;\n\nexport function basenameWithoutExt(p) {\n  return ext => path.basename(p, ext);\n}\n\nexport const extname = path.extname;\nexport const sep = path.sep;\nexport const delimiter = path.delimiter;\nexport const parse = path.parse;\nexport const isAbsolute = path.isAbsolute;\n", "-- | This module defines data type for the different platforms supported by\n-- | Node.js\nmodule Node.Platform where\n\nimport Prelude\nimport Data.Maybe (Maybe(..))\n\n-- | See [the Node docs](https://nodejs.org/dist/latest-v6.x/docs/api/os.html#os_os_platform).\ndata Platform\n  = AIX\n  | Darwin\n  | FreeBSD\n  | Linux\n  | OpenBSD\n  | SunOS\n  | Win32\n  | Android\n\n-- | The String representation for a platform, recognised by Node.js.\ntoString :: Platform -> String\ntoString AIX     = \"aix\"\ntoString Darwin  = \"darwin\"\ntoString FreeBSD = \"freebsd\"\ntoString Linux   = \"linux\"\ntoString OpenBSD = \"openbsd\"\ntoString SunOS   = \"sunos\"\ntoString Win32   = \"win32\"\ntoString Android = \"android\"\n\n-- | Attempt to parse a `Platform` value from a string, in the format returned\n-- | by Node.js' `process.platform`.\nfromString :: String -> Maybe Platform\nfromString \"aix\"     = Just AIX\nfromString \"darwin\"  = Just Darwin\nfromString \"freebsd\" = Just FreeBSD\nfromString \"linux\"   = Just Linux\nfromString \"openbsd\" = Just OpenBSD\nfromString \"sunos\"   = Just SunOS\nfromString \"win32\"   = Just Win32\nfromString \"android\" = Just Android\nfromString _         = Nothing\n\ninstance showPlatform :: Show Platform where\n  show AIX     = \"AIX\"\n  show Darwin  = \"Darwin\"\n  show FreeBSD = \"FreeBSD\"\n  show Linux   = \"Linux\"\n  show OpenBSD = \"OpenBSD\"\n  show SunOS   = \"SunOS\"\n  show Win32   = \"Win32\"\n  show Android = \"Android\"\n\nderive instance eqPlatform :: Eq Platform\nderive instance ordPlatform :: Ord Platform\n", "import process from \"process\";\nexport { process };\n\nexport function onBeforeExit(callback) {\n  return () => {\n    process.on(\"beforeExit\", callback);\n  };\n}\n\nexport function onExit(callback) {\n  return () => {\n    process.on(\"exit\", code => {\n      callback(code)();\n    });\n  };\n}\n\nexport function onUncaughtException(callback) {\n  return () => {\n    process.on(\"uncaughtException\", error => {\n      callback(error)();\n    });\n  };\n}\n\nexport function onUnhandledRejection(callback) {\n  return () => {\n    process.on(\"unhandledRejection\", (error, promise) => {\n      callback(error)(promise)();\n    });\n  };\n}\n\nexport function onSignalImpl(signal) {\n  return callback => () => {\n    process.on(signal, callback);\n  };\n}\n\nexport function chdir(dir) {\n  return () => {\n    process.chdir(dir);\n  };\n}\n\nexport function setEnv(var_) {\n  return val => () => {\n    process.env[var_] = val;\n  };\n}\n\nexport function unsetEnv(var_) {\n  return () => {\n    delete process.env[var_];\n  };\n}\n\nexport function exit(code) {\n  return () => {\n    process.exit(code);\n  };\n}\n\nexport function copyArray(xs) {\n  return () => xs.slice();\n}\n\nexport function copyObject(o) {\n  return () => Object.assign({}, o);\n}\n", "export function _copyST(m) {\n  return function () {\n    var r = {};\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r[k] = m[k];\n      }\n    }\n    return r;\n  };\n}\n\nexport const empty = {};\n\nexport function runST(f) {\n  return f();\n}\n\nexport function _fmapObject(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _mapWithKey(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(k)(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _foldM(bind) {\n  return function (f) {\n    return function (mz) {\n      return function (m) {\n        var acc = mz;\n        function g(k) {\n          return function (z) {\n            return f(z)(k)(m[k]);\n          };\n        }\n        for (var k in m) {\n          if (hasOwnProperty.call(m, k)) {\n            acc = bind(acc)(g(k));\n          }\n        }\n        return acc;\n      };\n    };\n  };\n}\n\nexport function _foldSCObject(m, z, f, fromMaybe) {\n  var acc = z;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      var maybeR = f(acc)(k)(m[k]);\n      var r = fromMaybe(null)(maybeR);\n      if (r === null) return acc;\n      else acc = r;\n    }\n  }\n  return acc;\n}\n\nexport function all(f) {\n  return function (m) {\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k) && !f(k)(m[k])) return false;\n    }\n    return true;\n  };\n}\n\nexport function size(m) {\n  var s = 0;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      ++s;\n    }\n  }\n  return s;\n}\n\nexport function _lookup(no, yes, k, m) {\n  return k in m ? yes(m[k]) : no;\n}\n\nexport function _lookupST(no, yes, k, m) {\n  return function () {\n    return k in m ? yes(m[k]) : no;\n  };\n}\n\nexport function toArrayWithKey(f) {\n  return function (m) {\n    var r = [];\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r.push(f(k)(m[k]));\n      }\n    }\n    return r;\n  };\n}\n\nexport const keys = Object.keys || toArrayWithKey(function (k) {\n  return function () { return k; };\n});\n", "-- | Bindings to the global `process` object in Node.js. See also [the Node API documentation](https://nodejs.org/api/process.html)\nmodule Node.Process\n  ( onBeforeExit\n  , onExit\n  , onSignal\n  , onUncaughtException\n  , onUnhandledRejection\n  , nextTick\n  , argv\n  , execArgv\n  , execPath\n  , chdir\n  , cwd\n  , getEnv\n  , lookupEnv\n  , setEnv\n  , unsetEnv\n  , pid\n  , platform\n  , exit\n  , stdin\n  , stdout\n  , stderr\n  , stdinIsTTY\n  , stdoutIsTTY\n  , stderrIsTTY\n  , version\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Posix (Pid)\nimport Data.Posix.Signal (Signal)\nimport Data.Posix.Signal as Signal\nimport Effect (Effect)\nimport Effect.Exception (Error)\nimport Foreign.Object as FO\nimport Node.Platform (Platform)\nimport Node.Platform as Platform\nimport Node.Stream (Readable, Writable)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- YOLO\nforeign import process :: forall props. { | props }\n\nmkEffect :: forall a. (Unit -> a) -> Effect a\nmkEffect = unsafeCoerce\n\n-- | Register a callback to be performed when the event loop empties, and\n-- | Node.js is about to exit. Asynchronous calls can be made in the callback,\n-- | and if any are made, it will cause the process to continue a little longer.\nforeign import onBeforeExit :: Effect Unit -> Effect Unit\n\n-- | Register a callback to be performed when the process is about to exit.\n-- | Any work scheduled via asynchronous calls made here will not be performed\n-- | in time.\n-- |\n-- | The argument to the callback is the exit code which the process is about\n-- | to exit with.\nforeign import onExit :: (Int -> Effect Unit) -> Effect Unit\n\n-- | Install a handler for uncaught exceptions. The callback will be called\n-- | when the process emits the `uncaughtException` event. The handler\n-- | currently does not expose the second `origin` argument from the Node 12\n-- | version of this event to maintain compatibility with older Node versions.\nforeign import onUncaughtException :: (Error -> Effect Unit) -> Effect Unit\n\n-- | Install a handler for unhandled promise rejections. The callback will be\n-- | called when the process emits the `unhandledRejection` event.\n-- |\n-- | The first argument to the handler can be whatever type the unhandled\n-- | Promise yielded on rejection (typically, but not necessarily, an `Error`).\n-- |\n-- | The handler currently does not expose the type of the second argument,\n-- | which is a `Promise`, in order to allow users of this library to choose\n-- | their own PureScript `Promise` bindings.\nforeign import onUnhandledRejection :: forall a b. (a -> b -> Effect Unit) -> Effect Unit\n\nforeign import onSignalImpl :: String -> Effect Unit -> Effect Unit\n\n-- | Install a handler for a particular signal.\nonSignal :: Signal -> Effect Unit -> Effect Unit\nonSignal sig = onSignalImpl (Signal.toString sig)\n\n-- | Register a callback to run as soon as the current event loop runs to\n-- | completion.\nnextTick :: Effect Unit -> Effect Unit\nnextTick callback = mkEffect \\_ -> process.nextTick callback\n\n-- | Get an array containing the command line arguments.\nargv :: Effect (Array String)\nargv = copyArray process.argv\n\n-- | Node-specific options passed to the `node` executable.\nexecArgv :: Effect (Array String)\nexecArgv = copyArray process.execArgv\n\n-- | The absolute pathname of the `node` executable that started the\n-- | process.\nexecPath :: Effect String\nexecPath = mkEffect \\_ -> process.execPath\n\n-- | Change the current working directory of the process. If the current\n-- | directory could not be changed, an exception will be thrown.\nforeign import chdir :: String -> Effect Unit\n\n-- | Get the current working directory of the process.\ncwd :: Effect String\ncwd = process.cwd\n\n-- | Get a copy of the current environment.\ngetEnv :: Effect (FO.Object String)\ngetEnv = copyObject process.env\n\n-- | Lookup a particular environment variable.\nlookupEnv :: String -> Effect (Maybe String)\nlookupEnv k = lookupMutableObject k process.env\n\n-- | Set an environment variable.\nforeign import setEnv :: String -> String -> Effect Unit\n\n-- | Delete an environment variable.\n-- | Use case: to hide secret environment variable from child processes.\nforeign import unsetEnv :: String -> Effect Unit\n\npid :: Pid\npid = process.pid\n\nplatform :: Maybe Platform\nplatform = Platform.fromString platformStr\n\nplatformStr :: String\nplatformStr = process.platform\n\n-- | Cause the process to exit with the supplied integer code. An exit code\n-- | of 0 is normally considered successful, and anything else is considered a\n-- | failure.\nforeign import exit :: forall a. Int -> Effect a\n\n-- | The standard input stream. Note that this stream will never emit an `end`\n-- | event, so any handlers attached via `onEnd` will never be called.\nstdin :: Readable ()\nstdin = process.stdin\n\n-- | The standard output stream. Note that this stream cannot be closed; calling\n-- | `end` will result in an exception being thrown.\nstdout :: Writable ()\nstdout = process.stdout\n\n-- | The standard error stream. Note that this stream cannot be closed; calling\n-- | `end` will result in an exception being thrown.\nstderr :: Writable ()\nstderr = process.stderr\n\n-- | Check whether the standard input stream appears to be attached to a TTY.\n-- | It is a good idea to check this before processing the input data from stdin.\nstdinIsTTY :: Boolean\nstdinIsTTY = process.stdin.isTTY\n\n-- | Check whether the standard output stream appears to be attached to a TTY.\n-- | It is a good idea to check this before printing ANSI codes to stdout\n-- | (e.g. for coloured text in the terminal).\nstdoutIsTTY :: Boolean\nstdoutIsTTY = process.stdout.isTTY\n\n-- | Check whether the standard error stream appears to be attached to a TTY.\n-- | It is a good idea to check this before printing ANSI codes to stderr\n-- | (e.g. for coloured text in the terminal).\nstderrIsTTY :: Boolean\nstderrIsTTY = process.stderr.isTTY\n\n-- | Get the Node.js version.\nversion :: String\nversion = process.version\n\n-- Utils\n\nforeign import data MutableArray :: Type -> Type\nforeign import data MutableObject :: Type -> Type\n\nforeign import copyArray :: forall a. MutableArray a -> Effect (Array a)\nforeign import copyObject :: forall a. MutableObject a -> Effect (FO.Object a)\n\nlookupMutableObject :: forall a. String -> MutableObject a -> Effect (Maybe a)\nlookupMutableObject k o =\n  mkEffect \\_ -> FO.lookup k (unsafeCoerce o)\n", "-- | GitHub action to generate Codecov test coverage report of\n-- | cabalized Haskell package with `hpc-codecov`.\n\nmodule Main where\n\nimport Prelude\n\n-- effect\nimport Effect (Effect)\nimport Effect.Class (liftEffect)\n\n-- aff\nimport Effect.Aff (Aff, runAff_)\n\n-- either\nimport Data.Either (Either(..))\n\n-- exceptions\nimport Effect.Exception (Error, error, message)\n\n-- maybe\nimport Data.Maybe (Maybe(..), maybe)\n\n-- node-fs\nimport Node.FS.Perms (mkPerms, read, execute, all)\nimport Node.FS.Constants (x_OK)\n\n-- node-fs-aff\nimport Node.FS.Aff (access', chmod)\n\n-- node-path\nimport Node.Path (resolve)\n\n-- node-process\nimport Node.Platform (Platform(..))\nimport Node.Process (platform)\n\n-- transformers\nimport Control.Monad.Except (ExceptT, except, runExceptT, throwError, lift)\n\n-- github-actions-toolkit\nimport GitHub.Actions.Core as Core\nimport GitHub.Actions.Exec as Exec\n\n\n-- ------------------------------------------------------------------------\n--\n-- The main function\n--\n-- ------------------------------------------------------------------------\n\nmain :: Effect Unit\nmain = flip runAff_ mainAff $ \\et_done ->\n  case et_done of\n    Right _ -> pure unit\n    Left err -> Core.setFailed $ message err\n\nmainAff :: Aff Unit\nmainAff = runAction work\n\n\n-- ------------------------------------------------------------------------\n--\n-- Internal work\n--\n-- ------------------------------------------------------------------------\n\ntype Action a = ExceptT Error Aff a\n\nrunAction :: forall a. Action a -> Aff a\nrunAction act = do\n  et_ret <- runExceptT act\n  case et_ret of\n    Right ret -> pure ret\n    Left err -> throwError err\n\n-- | The guts.\nwork :: Action Unit\nwork = getInputs >>= doWork >>= setOutputs\n\n-- | The guts of guts.\ndoWork :: Inputs -> Action Outputs\ndoWork inputs = do\n  meta <- getHpcCodecovMeta\n  resolved <- liftEffect $ resolve [] meta.exe\n  mb_err <- lift $ access' resolved x_OK\n  let {msg, mb_exe} = case mb_err of\n        Just _ -> {msg: \"Fetching \" <> meta.url, mb_exe: Nothing}\n        Nothing -> {msg: \"Reusing \" <> resolved, mb_exe: Just resolved}\n  liftEffect (Core.info msg)\n  doWorkWith meta inputs mb_exe\n\n-- | The guts of guts of guts.\ndoWorkWith\n  :: HpcCodecovMeta\n  -- ^ Meta information to get `hpc-codecov`.\n  -> Inputs\n  -- ^ Input paramater object.\n  -> Maybe String\n  -- ^ 'Just' path to `hpc-codecov`, or 'Nothing' to download latest\n  -- release from the github repository.\n  -> Action Outputs\n  -- ^ Output object of this action.\ndoWorkWith meta inputs mb_hpc_codecov = do\n  hpc_codecov <- maybe (getHpcCodecov meta) pure mb_hpc_codecov\n  args <- map Just $ getHpcCodecovArgs inputs\n  let options = Just $ Exec.defaultExecOptions {cwd = Just inputs.root}\n  exec {command: hpc_codecov, args, options}\n  report <- liftEffect $ resolve [inputs.root] inputs.out\n  pure {exe: hpc_codecov, report}\n\n\n-- ------------------------------------------------------------------------\n--\n-- Inputs and outputs\n--\n-- ------------------------------------------------------------------------\n\n-- | Purescript representation of input information specified in\n-- | `action.yml`.\ntype Inputs =\n  { target :: String\n  , mix :: String\n  , src :: String\n  , excludes :: String\n  , out :: String\n  , format :: Format\n  , root :: String\n  , build :: String\n  , skip :: String\n  , verbose :: Boolean\n  }\n\n-- | Purescript representation of output information specified in\n-- | `action.yml`.\ntype Outputs =\n  { exe :: String\n  , report :: String\n  }\n\n-- | Purescript representation of supported output report format.\ndata Format = Codecov | Lcov\n\ninstance Show Format where\n  show Codecov = \"codecov\"\n  show Lcov = \"lcov\"\n\n-- | Get github action inputs specified in `action.yml`.\ngetInputs :: Action Inputs\ngetInputs = liftEffect (runExceptT go) >>= except\n  where\n    go = do\n      target <- requiredInput \"target\"\n      mix <- optionalInput \"mix\"\n      src <- optionalInput \"src\"\n      excludes <- optionalInput \"excludes\"\n      format <- getFormat\n      out <- defaultOutOnEmpty format <$> optionalInput \"out\"\n      verbose <- getVerbose\n      root <- optionalInput \"root\"\n      build <- optionalInput \"build\"\n      skip <- optionalInput \"skip\"\n\n      pure {target, mix, src, excludes, out, format, verbose, root, build, skip}\n\ngetVerbose :: ExceptT Error Effect Boolean\ngetVerbose = do\n  str <- optionalInput \"verbose\"\n  case str of\n    \"true\"  -> pure true\n    \"false\" -> pure false\n    _       -> do\n      liftEffect $ Core.warning $\n        \"expecting 'true' or 'false' for input 'verbose', but got \" <>\n        show str <> \", setting verbosity to 'true'.\"\n      pure true\n\ngetFormat :: ExceptT Error Effect Format\ngetFormat = do\n  str <- optionalInput \"format\"\n  case str of\n    \"codecov\" -> pure Codecov\n    \"lcov\" -> pure Lcov\n    _ -> do\n      liftEffect $ Core.error $\n        \"expecting 'codecov' or 'lcov' for input 'format', but got \" <> show str\n      throwError (error (\"invalid format: \" <> show str))\n\ndefaultOutOnEmpty :: Format -> String -> String\ndefaultOutOnEmpty format str =\n  case format, str of\n    Codecov, \"\" -> \"codecov.json\"\n    Lcov, \"\"    -> \"lcov.info\"\n    _, _        -> str\n\noptionalInput :: String -> ExceptT Error Effect String\noptionalInput n = Core.getInput {name: n, options: Nothing}\n\nrequiredInput :: String -> ExceptT Error Effect String\nrequiredInput n = Core.getInput {name: n, options: Just {required: true}}\n\n-- | Set github action outputs on success, or set the action as failed\n-- | with error message on failure.\nsetOutputs :: Outputs -> Action Unit\nsetOutputs outputs = liftEffect do\n  Core.setOutput { name: \"exe\", value: outputs.exe }\n  Core.setOutput { name: \"report\", value: outputs.report }\n\n\n-- ------------------------------------------------------------------------\n--\n-- Fetching hpc-codecov\n--\n-- ------------------------------------------------------------------------\n\n-- | Meta information to download and save `hpc-codecov` executable binary.\ntype HpcCodecovMeta =\n  { url :: String\n    -- ^ URL to download the binary executable.\n  , exe :: String\n    -- ^ Local executable path.\n  }\n\n-- | Make a URL to download `hpc-codecov`.\nmkURL :: String -> String\nmkURL name =\n  \"https://github.com/8c6794b6/hpc-codecov/releases/download/v0.4.1.0/\"\n  <> name\n\n-- | Get meta information to download `hpc-codecov` executable for\n-- | supported platforms. This action will fail on unsupported\n-- | platforms, e.g. AIX, Android ... etc.\ngetHpcCodecovMeta :: Action HpcCodecovMeta\ngetHpcCodecovMeta = do\n  case platform of\n    Just Linux ->\n      pure {url: mkURL \"hpc-codecov-Linux\", exe: \"hpc-codecov\"}\n    Just Darwin ->\n      pure {url: mkURL \"hpc-codecov-macOS\", exe: \"hpc-codecov\"}\n    Just Win32 ->\n      pure {url: mkURL \"hpc-codecov-Windows.exe\", exe: \"hpc-codecov.exe\"}\n    _ ->\n      throwError $ error $ \"Unsupported platform: \" <> show platform\n\n-- | Download `hpc-codecov` executable. Internally uses `curl` to\n-- | simplify following redirect of the download URL.  Returns the\n-- | absolute path of the `hpc-codecov` executable.\ngetHpcCodecov :: HpcCodecovMeta -> Action String\ngetHpcCodecov meta = do\n  exec { command: \"curl\"\n       , args: Just [\"-sL\", \"--output\", meta.exe, meta.url]\n       , options: Nothing }\n  path <- liftEffect do\n    resolved <- resolve [] meta.exe\n    Core.info (\"Saved hpc-codecov to: \" <> resolved)\n    pure resolved\n  lift $ chmod path (mkPerms all (read + execute) (read + execute))\n  pure path\n\n\n-- ------------------------------------------------------------------------\n--\n-- Arguments for hpc-codecov\n--\n-- ------------------------------------------------------------------------\n\ngetHpcCodecovArgs :: Inputs -> Action (Array String)\ngetHpcCodecovArgs inputs = do\n  let f opt str = if str == \"\" then [] else [opt, str]\n  root_resolved <- liftEffect $ resolve [] inputs.root\n  pure $\n    [ inputs.target ] <>\n    f \"--mix\" inputs.mix <>\n    f \"--src\" inputs.src <>\n    f \"--exclude\" inputs.excludes <>\n    f \"--out\" inputs.out <>\n    f \"--format\" (show inputs.format) <>\n    f \"--root\" root_resolved <>\n    f \"--build\" inputs.build <>\n    f \"--skip\" inputs.skip <>\n    if inputs.verbose then [\"--verbose\"] else []\n\n\n-- ------------------------------------------------------------------------\n--\n-- Auxliary\n--\n-- ------------------------------------------------------------------------\n\n-- | Execute and assert execution of external command.\nexec :: Exec.ExecArgs -> Action Unit\nexec args = do\n  ec <- Exec.exec args\n  when (ec /= 0.0) $\n    throwError $ error $ \"Got non zero exit code: \" <> show ec\n", "import {main} from \"../output/Main/index.js\";\nmain();\n"],
  "mappings": "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",
  "names": ["toCommandValue", "input", "exports", "toCommandProperties", "annotationProperties", "os", "__importStar", "utils_1", "issueCommand", "command", "properties", "message", "cmd", "Command", "exports", "issue", "name", "CMD_STRING", "cmdStr", "first", "key", "val", "escapeProperty", "escapeData", "s", "crypto", "rng", "poolPtr", "rnds8Pool", "init_rng", "__esmMin", "regex_default", "init_regex", "__esmMin", "validate", "uuid", "regex_default", "validate_default", "init_validate", "__esmMin", "init_regex", "stringify", "arr", "offset", "uuid", "byteToHex", "validate_default", "stringify_default", "init_stringify", "__esmMin", "init_validate", "i", "v1", "options", "buf", "offset", "i", "b", "node", "_nodeId", "clockseq", "_clockseq", "seedBytes", "rng", "msecs", "nsecs", "_lastNSecs", "dt", "_lastMSecs", "tl", "tmh", "n", "stringify_default", "v1_default", "init_v1", "__esmMin", "init_rng", "init_stringify", "parse", "uuid", "validate_default", "v", "arr", "parse_default", "init_parse", "__esmMin", "init_validate", "stringToBytes", "str", "bytes", "i", "v35_default", "name", "version", "hashfunc", "generateUUID", "value", "namespace", "buf", "offset", "parse_default", "stringify_default", "DNS", "URL", "init_v35", "__esmMin", "init_stringify", "init_parse", "crypto", "md5", "bytes", "md5_default", "init_md5", "__esmMin", "v3", "v3_default", "init_v3", "__esmMin", "init_v35", "init_md5", "v35_default", "md5_default", "v4", "options", "buf", "offset", "rnds", "rng", "i", "stringify_default", "v4_default", "init_v4", "__esmMin", "init_rng", "init_stringify", "crypto", "sha1", "bytes", "sha1_default", "init_sha1", "__esmMin", "v5", "v5_default", "init_v5", "__esmMin", "init_v35", "init_sha1", "v35_default", "sha1_default", "nil_default", "init_nil", "__esmMin", "version", "uuid", "validate_default", "version_default", "init_version", "__esmMin", "init_validate", "esm_node_exports", "__export", "nil_default", "parse_default", "stringify_default", "v1_default", "v3_default", "v4_default", "v5_default", "validate_default", "version_default", "init_esm_node", "__esmMin", "init_v1", "init_v3", "init_v4", "init_v5", "init_nil", "init_version", "init_validate", "init_stringify", "init_parse", "fs", "__importStar", "os", "uuid_1", "utils_1", "issueFileCommand", "command", "message", "filePath", "exports", "prepareKeyValueMessage", "key", "value", "delimiter", "convertedValue", "getProxyUrl", "reqUrl", "usingSsl", "checkBypass", "proxyVar", "exports", "reqHost", "isLoopbackAddress", "noProxy", "reqPort", "upperReqHosts", "upperNoProxyItem", "x", "host", "hostLower", "require_tunnel", "__commonJSMin", "exports", "net", "tls", "http", "https", "events", "assert", "util", "httpOverHttp", "httpsOverHttp", "httpOverHttps", "httpsOverHttps", "options", "agent", "TunnelingAgent", "createSecureSocket", "self", "socket", "host", "port", "localAddress", "toOptions", "i", "len", "pending", "req", "mergeOptions", "onFree", "onCloseOrRemove", "err", "cb", "placeholder", "connectOptions", "debug", "connectReq", "onResponse", "onUpgrade", "onConnect", "onError", "res", "head", "error", "cause", "pos", "hostHeader", "tlsOptions", "secureSocket", "target", "overrides", "keys", "j", "keyLen", "k", "args", "require_tunnel", "__commonJSMin", "exports", "module", "http", "__importStar", "https", "pm", "tunnel", "HttpCodes", "exports", "Headers", "MediaTypes", "getProxyUrl", "serverUrl", "proxyUrl", "HttpRedirectCodes", "HttpResponseRetryCodes", "RetryableHttpVerbs", "ExponentialBackoffCeiling", "ExponentialBackoffTimeSlice", "HttpClientError", "_HttpClientError", "message", "statusCode", "HttpClientResponse", "resolve", "__awaiter", "output", "chunk", "chunks", "isHttps", "requestUrl", "HttpClient", "userAgent", "handlers", "requestOptions", "additionalHeaders", "data", "verb", "stream", "res", "obj", "headers", "parsedUrl", "info", "maxTries", "numTries", "response", "authenticationHandler", "handler", "redirectsRemaining", "redirectUrl", "parsedRedirectUrl", "header", "reject", "callbackForResult", "err", "onResult", "callbackCalled", "handleResult", "req", "msg", "socket", "sock", "method", "usingSsl", "defaultPort", "lowercaseKeys", "_default", "clientHeader", "agent", "useProxy", "maxSockets", "agentOptions", "tunnelAgent", "overHttps", "options", "retryNumber", "ms", "dateTimeDeserializer", "key", "value", "a", "contents", "c", "k", "BasicCredentialHandler", "username", "password", "options", "exports", "BearerCredentialHandler", "token", "PersonalAccessTokenCredentialHandler", "http_client_1", "auth_1", "core_1", "OidcClient", "_OidcClient", "allowRetry", "maxRetry", "requestOptions", "token", "runtimeUrl", "id_token_url", "id_token", "_a", "error", "audience", "encodedAudience", "exports", "os_1", "fs_1", "access", "appendFile", "writeFile", "exports", "Summary", "pathFromEnv", "tag", "content", "attrs", "htmlAttrs", "key", "value", "options", "overwrite", "filePath", "text", "addEOL", "code", "lang", "element", "items", "ordered", "listItems", "item", "rows", "tableBody", "row", "cells", "cell", "header", "data", "colspan", "rowspan", "label", "src", "alt", "width", "height", "level", "allowedTag", "cite", "href", "_summary", "path", "__importStar", "toPosixPath", "pth", "exports", "toWin32Path", "toPlatformPath", "command_1", "file_command_1", "utils_1", "os", "__importStar", "path", "oidc_utils_1", "ExitCode", "exports", "exportVariable", "name", "val", "convertedVal", "setSecret", "secret", "addPath", "inputPath", "getInput", "options", "getMultilineInput", "inputs", "x", "input", "getBooleanInput", "trueValue", "falseValue", "setOutput", "value", "setCommandEcho", "enabled", "setFailed", "message", "error", "isDebug", "debug", "properties", "warning", "notice", "info", "startGroup", "endGroup", "group", "fn", "result", "saveState", "getState", "getIDToken", "aud", "summary_1", "summary_2", "path_utils_1", "fs", "__importStar", "path", "_a", "exports", "exists", "fsPath", "err", "isDirectory", "useStat", "isRooted", "p", "normalizeSeparators", "tryGetExecutablePath", "filePath", "extensions", "stats", "upperExt", "validExt", "isUnixExecutable", "originalFilePath", "extension", "directory", "upperName", "actualName", "getCmdPath", "assert_1", "path", "__importStar", "ioUtil", "cp", "source", "dest", "options", "force", "recursive", "copySourceDirectory", "readCopyOptions", "destStat", "newDest", "cpDirRecursive", "copyFile", "exports", "mv", "destExists", "rmRF", "mkdirP", "inputPath", "err", "fsPath", "which", "tool", "check", "result", "matches", "findInPath", "extensions", "extension", "filePath", "directories", "p", "directory", "sourceDir", "destDir", "currentDepth", "files", "fileName", "srcFile", "destFile", "e", "symlinkFull", "os", "__importStar", "events", "child", "path", "io", "ioUtil", "timers_1", "IS_WINDOWS", "ToolRunner", "toolPath", "args", "options", "message", "noPrefix", "cmd", "a", "data", "strBuffer", "onLine", "s", "n", "line", "err", "argline", "str", "end", "upperToolPath", "arg", "cmdSpecialChars", "needsQuotes", "char", "x", "reverse", "quoteHit", "i", "result", "resolve", "reject", "__awaiter", "optionsNonNull", "state", "ExecState", "fileName", "cp", "stdbuffer", "errbuffer", "code", "error", "exitCode", "exports", "argStringToArray", "argString", "inQuotes", "escaped", "append", "c", "_ExecState", "string_decoder_1", "tr", "__importStar", "exec", "commandLine", "args", "options", "commandArgs", "toolPath", "exports", "getExecOutput", "stdout", "stderr", "stdoutDecoder", "stderrDecoder", "originalStdoutListener", "_a", "originalStdErrListener", "_b", "stdErrListener", "data", "stdOutListener", "listeners", "exitCode", "semigroupoidFn", "f", "g", "x", "identity", "dict", "categoryFn", "x", "otherwise", "flip", "f", "b", "a", "$$const", "v", "map", "dict", "$$void", "dictFunctor", "map", "$$const", "voidLeft", "f", "x", "voidRight", "apply", "dict", "applySecond", "dictApply", "apply", "a", "b", "pure", "dict", "when", "dictApplicative", "pure", "v", "v1", "pure1", "liftA1", "f", "discard", "dict", "bind", "dict", "bindFlipped", "dictBind", "discardUnit", "dictBind", "bind", "concatArray", "xs", "ys", "semigroupArray", "append", "dict", "alt", "dict", "topChar", "bottomChar", "topNumber", "bottomNumber", "one", "dict", "add", "dict", "showIntImpl", "showNumberImpl", "str", "showStringImpl", "s", "l", "c", "i", "k", "empty", "showString", "showNumber", "showInt", "show", "dict", "Nothing", "Just", "showMaybe", "dictShow", "v", "show", "maybe", "v", "v1", "v2", "Nothing", "Just", "functorMaybe", "v", "v1", "Just", "Nothing", "Left", "Right", "functorEither", "either", "v", "v1", "v2", "Left", "Right", "pureE", "a", "bindE", "f", "ap", "dictMonad", "f", "f$prime", "a$prime", "mempty", "dict", "monadEffect", "bindEffect", "applicativeEffect", "functorEffect", "$lazy_functorEffect", "error", "msg", "message", "e", "throwException", "e", "catchException", "c", "t", "throwError", "dict", "monadThrowEffect", "monadErrorEffect", "catchError", "dict", "$$try", "dictMonadError", "catchError", "a", "$52", "Identity", "x", "functorIdentity", "applyIdentity", "v", "v1", "bindIdentity", "f", "applicativeIdentity", "Identity", "monadIdentity", "lift", "dict", "monadEffectEffect", "liftEffect", "dict", "ExceptT", "x", "runExceptT", "v", "monadTransExceptT", "dictMonad", "m", "mapExceptT", "f", "v", "functorExceptT", "dictFunctor", "map1", "map", "except", "dictApplicative", "$185", "pure", "$186", "ExceptT", "monadExceptT", "bindExceptT", "k", "bind", "either", "$187", "a", "v1", "applyExceptT", "applicativeExceptT", "$188", "$189", "Right", "monadEffectExceptT", "dictMonadEffect", "$190", "lift", "Monad0", "$191", "liftEffect", "$192", "monadThrowExceptT", "dictMonad", "$198", "pure", "$199", "ExceptT", "Left", "altExceptT", "dictSemigroup", "dictMonad", "v", "v1", "bind", "rm", "Right", "pure", "Left", "rn", "append", "Aff", "EMPTY", "PURE", "THROW", "CATCH", "SYNC", "ASYNC", "BIND", "BRACKET", "FORK", "SEQ", "MAP", "APPLY", "ALT", "CONS", "RESUME", "RELEASE", "FINALIZER", "FINALIZED", "FORKED", "FIBER", "THUNK", "tag", "_1", "_2", "_3", "AffCtr", "fn", "nonCanceler", "error", "runEff", "eff", "runSync", "left", "right", "runAsync", "k", "Scheduler", "limit", "size", "ix", "queue", "draining", "drain", "thunk", "cb", "i", "tmp", "Supervisor", "util", "fibers", "fiberId", "count", "fiber", "fid", "result", "killError", "killCount", "kills", "kill", "SUSPENDED", "CONTINUE", "STEP_BIND", "STEP_RESULT", "PENDING", "RETURN", "COMPLETED", "Fiber", "supervisor", "aff", "runTick", "status", "step", "fail", "interrupt", "bhead", "btail", "attempts", "bracketCount", "joinId", "joins", "rethrow", "run", "localRunTick", "attempt", "e", "sequential", "onComplete", "join", "jid", "canceler", "runPar", "par", "killId", "early", "root", "head", "tail", "kid", "loop", "lhs", "rhs", "resolve", "cancel", "innerKills", "newKills", "killCb", "_pure", "_throwError", "_catchError", "_map", "f", "value", "_bind", "_liftEffect", "Aff", "_parAffMap", "f", "aff", "_parAffApply", "aff1", "aff2", "makeAff", "Aff", "_makeFiber", "util", "aff", "Aff", "_delay", "setDelay", "n", "k", "clearDelay", "t", "right", "ms", "Aff", "cb", "timer", "_sequential", "unsafeCoerce", "x", "empty", "dict", "coerce", "unwrap", "sequential", "dict", "parallel", "foldrArray", "f", "init", "xs", "acc", "len", "i", "foldlArray", "foldr", "dict", "traverse_", "dictApplicative", "dictFoldable", "foldr", "f", "$454", "foldl", "dict", "foldMapDefaultR", "dictFoldable", "foldr", "dictMonoid", "f", "x", "acc", "foldableArray", "traverseArrayImpl", "array1", "array2", "b", "array3", "c", "concat2", "xs", "ys", "apply", "map", "pure", "array", "go", "bot", "top", "pivot", "parTraverse_", "dictParallel", "dictFoldable", "f", "$48", "traverse_1", "$50", "$49", "parSequence_", "dictParallel", "parTraverse_", "dictFoldable", "_unsafePartial", "f", "_crashWith", "msg", "crashWith", "unsafePartial", "_unsafePartial", "unsafeCrashWith", "msg", "functorParAff", "functorAff", "ffiUtil", "unsafeFromRight", "v", "Right", "Left", "unsafeCrashWith", "unsafeFromLeft", "isLeft", "makeFiber", "aff", "launchAff", "fiber", "applyParAff", "monadAff", "bindAff", "applicativeAff", "monadEffectAff", "monadThrowAff", "monadErrorAff", "runAff", "k", "aff", "launchAff", "bindFlipped", "$80", "runAff_", "parallelAff", "$82", "parallel", "$83", "pure2", "semigroupCanceler", "v", "v1", "err", "nonCanceler", "$$const", "pure2", "monoidCanceler", "import_core", "exportVariableImpl", "core", "setSecretImpl", "addPathImpl", "getInput1Impl", "getInput2Impl", "setOutputImpl", "setCommandEchoImpl", "setFailedImpl", "isDebugImpl", "debugImpl", "errorImpl", "warningImpl", "infoImpl", "startGroupImpl", "endGroupImpl", "saveStateImpl", "getStateImpl", "groupImpl", "thenImpl", "promise", "errCB", "succCB", "runExcept", "$3", "NonEmpty", "singleton", "dictPlus", "a", "empty", "Nil", "Cons", "NonEmptyList", "x", "toList", "v", "listMap", "f", "chunkedRevMap", "$copy_v", "$copy_v1", "v1", "Cons", "$tco_var_v", "v", "unrolledMap", "v2", "Nil", "reverseUnrolledMap", "$copy_v2", "$copy_v3", "$tco_var_v2", "v3", "$tco_done1", "functorList", "foldableList", "f", "b", "rev", "go", "$copy_v", "$copy_v1", "v1", "Nil", "v", "Cons", "$tco_var_v", "$284", "foldl", "flip", "$285", "$copy_b", "$tco_var_b", "dictMonoid", "acc", "$286", "append2", "$287", "semigroupList", "xs", "ys", "semigroupNonEmptyList", "v", "as$prime", "NonEmpty", "append1", "toList", "altList", "plusList", "tagOf", "value", "isArray", "value", "singleton", "$200", "plusList", "$201", "TypeMismatch", "unsafeFromForeign", "unsafeCoerce", "fail", "dictMonad", "$153", "throwError", "monadThrowExceptT", "$154", "singleton", "unsafeReadTagged", "dictMonad", "fail", "tag", "value", "tagOf", "unsafeFromForeign", "otherwise", "readString", "dictMonad", "unsafeReadTagged", "toAff$prime", "customCoerce", "p", "cb", "$14", "Left", "$15", "Right", "coerce", "fn", "v", "map", "error", "readString", "toAff", "toAff$prime", "toAffE", "f", "mkEffectFn1", "fn", "x", "runEffectFn1", "fn", "a", "warning", "runEffectFn1", "warningImpl", "setOutput", "v", "setFailed", "runEffectFn1", "setFailedImpl", "info", "runEffectFn1", "infoImpl", "getInput", "handleOptions", "v", "Nothing", "Just", "$24", "$$try", "monadErrorEffect", "$25", "error", "runEffectFn1", "errorImpl", "import_exec", "exec1Impl", "exec", "exec2Impl", "exec2Impl2", "command", "options", "exec3Impl", "nullable", "a", "f", "notNull", "x", "toNullable", "maybe", "notNull", "toMaybe", "Nothing", "Just", "toJSExecListeners", "v", "toJSExecOptions", "exec", "handleOptions", "Nothing", "Just", "$34", "$$try", "monadErrorAff", "$35", "toAffE", "defaultExecOptions", "access", "copyFile", "mkdtemp", "rename", "truncate", "chown", "chmod", "stat", "lstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "rm", "mkdir", "readdir", "utimes", "readFile", "writeFile", "appendFile", "open", "read", "write", "close", "constants", "f_OK", "r_OK", "w_OK", "x_OK", "copyFile_EXCL", "copyFile_FICLONE", "copyFile_FICLONE_FORCE", "hasArrayFrom", "hasStringIterator", "hasFromCodePoint", "hasCodePointAt", "replicateFill", "count", "value", "result", "replicatePolyfill", "n", "i", "replicateImpl", "fromFoldableImpl", "Cons", "head", "tail", "emptyList", "curryCons", "listToArray", "list", "xs", "foldr", "sortByImpl", "mergeFromTo", "compare", "fromOrdering", "xs1", "xs2", "from", "to", "mid", "i", "j", "k", "x", "y", "c", "xs", "out", "sortByImpl", "mergeFromTo", "compare", "fromOrdering", "xs1", "xs2", "from", "to", "mid", "i", "j", "k", "x", "y", "c", "xs", "semiringPerm", "v", "v1", "read", "permToInt", "v", "permToString", "$119", "show", "showInt", "$120", "permsToString", "mkPerms", "u", "g", "o", "execute", "all", "one", "semiringPerm", "handleCallback", "cb", "err", "a", "v", "toMaybe", "Nothing", "Right", "Just", "Left", "chmod", "file", "perms", "cb", "permsToString", "handleCallback", "access$prime", "path", "mode", "cb", "err", "toMaybe", "toAff", "p", "k", "nonCanceler", "toAff2", "f", "a", "b", "toAff", "chmod", "toAff2", "access$prime", "path", "mode", "k", "$5", "Right", "path", "normalize", "resolve", "from", "to", "path", "basename", "path", "extname", "path", "sep", "delimiter", "parse", "isAbsolute", "AIX", "Darwin", "FreeBSD", "Linux", "OpenBSD", "SunOS", "Win32", "Android", "showPlatform", "v", "AIX", "Darwin", "FreeBSD", "Linux", "OpenBSD", "SunOS", "Win32", "Android", "fromString", "Nothing", "process", "toArrayWithKey", "f", "m", "r", "k", "keys", "platformStr", "platform", "fromString", "Codecov", "Lcov", "showFormat", "v", "setOutputs", "outputs", "runAction", "act", "et_ret", "Right", "pure", "Left", "throwError", "requiredInput", "optionalInput", "mkURL", "name", "getVerbose", "bind1", "str", "discard2", "liftEffect1", "warning", "show", "getHpcCodecovMeta", "platform", "Just", "Linux", "Darwin", "Win32", "throwError1", "error", "showMaybe", "showPlatform", "getHpcCodecovArgs", "inputs", "f", "opt", "$56", "root_resolved", "append1", "show2", "getFormat", "exec", "args", "ec", "show1", "getHpcCodecov", "meta", "resolved", "path", "mkPerms", "all", "add", "read", "execute", "doWorkWith", "mb_hpc_codecov", "pure2", "hpc_codecov", "options", "report", "doWork", "x_OK", "mb_err", "Nothing", "discard3", "liftEffect", "info", "defaultOutOnEmpty", "format", "getInputs", "go", "target", "mix", "src", "excludes", "out", "verbose", "root", "build", "skip", "except", "applicativeAff", "work", "bind2", "mainAff", "main", "flip", "runAff_", "et_done", "pure3", "setFailed", "message", "main"]
}
